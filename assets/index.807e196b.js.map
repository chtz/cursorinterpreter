{"version":3,"file":"index.807e196b.js","sources":["../../vite/modulepreload-polyfill","../../node_modules/react-dom/client.js","../../src/components/Header.jsx","../../src/components/Footer.jsx","../../src/components/Layout.jsx","../../src/components/ide/SourceEditor.jsx","../../src/components/ide/ConsoleOutput.jsx","../../src/components/ide/JsonEditor.jsx","../../src/interpreter/tokens.js","../../src/interpreter/lexer.js","../../src/interpreter/runtime.js","../../src/interpreter/ast.js","../../src/interpreter/parser.js","../../src/interpreter/index.js","../../src/components/ide/IDE.jsx","../../src/pages/Home.jsx","../../src/App.jsx","../../src/main.jsx"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","function Header() {\n  return (\n    <header className=\"bg-blue-600 text-white p-4 shadow-md\">\n      <div className=\"container mx-auto\">\n        <h1 className=\"text-2xl font-bold\">The Interpreter</h1>\n      </div>\n    </header>\n  );\n}\n\nexport default Header; ","function Footer() {\n  const year = new Date().getFullYear();\n  \n  return (\n    <footer className=\"bg-gray-800 text-white p-4 mt-auto\">\n      <div className=\"container mx-auto text-center\">\n        <p>&copy; {year} cht_z. All rights reserved.</p>\n      </div>\n    </footer>\n  );\n}\n\nexport default Footer; ","import { Outlet } from 'react-router-dom';\nimport Header from './Header';\nimport Footer from './Footer';\n\nfunction Layout() {\n  return (\n    <div className=\"flex flex-col min-h-screen\">\n      <Header />\n      <main className=\"flex-grow container mx-auto p-4\">\n        <Outlet />\n      </main>\n      <Footer />\n    </div>\n  );\n}\n\nexport default Layout; ","function SourceEditor({ source, onSourceChange, onRun }) {\n  return (\n    <div className=\"border border-gray-300 rounded-md h-full flex flex-col\">\n      <div className=\"flex justify-between items-center p-2 bg-gray-100 border-gray-300\">\n        <h3 className=\"font-medium\">Source Code</h3>\n        <button \n          className=\"bg-green-500 text-white px-3 py-1 rounded-md hover:bg-green-600 flex items-center\"\n          onClick={onRun}\n          aria-label=\"Run code\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\">\n            <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z\" clipRule=\"evenodd\" />\n          </svg>\n          Run\n        </button>\n      </div>\n      <textarea \n        className=\"flex-grow p-4 font-mono text-sm resize-none focus:outline-none\"\n        placeholder=\"// Write your code here...\"\n        value={source}\n        onChange={(e) => onSourceChange(e.target.value)}\n        aria-label=\"Source code editor\"\n        spellCheck=\"false\"\n      />\n    </div>\n  );\n}\n\nexport default SourceEditor; ","function ConsoleOutput({ output }) {\n  return (\n    <div className=\"border border-gray-300 rounded-md h-full flex flex-col\">\n      <div className=\"bg-gray-100 p-2 border-b border-gray-300\">\n        <h3 className=\"font-medium\">Console Output</h3>\n      </div>\n      <div \n        className=\"flex-grow bg-gray-900 p-4 font-mono text-sm text-green-400 overflow-y-auto\"\n        role=\"log\"\n        aria-live=\"polite\"\n        aria-label=\"Console output\"\n      >\n        <div className=\"whitespace-pre-wrap\">\n          {output}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default ConsoleOutput; ","function JsonEditor({ jsonData, onJsonChange }) {\n  return (\n    <div className=\"border border-gray-300 rounded-md h-full flex flex-col\">\n      <div className=\"bg-gray-100 p-2 border-b border-gray-300\">\n        <h3 className=\"font-medium\">JSON Data</h3>\n      </div>\n      <textarea \n        className=\"flex-grow p-4 font-mono text-sm resize-none focus:outline-none bg-gray-50\"\n        placeholder=\"{}\"\n        value={jsonData}\n        onChange={(e) => onJsonChange(e.target.value)}\n        aria-label=\"JSON data editor\"\n        spellCheck=\"false\"\n      />\n    </div>\n  );\n}\n\nexport default JsonEditor; ","/**\n * Token types for the Cursor Interpreter language\n */\nexport const TokenType = {\n  // Special tokens\n  EOF: 'EOF',\n  ILLEGAL: 'ILLEGAL',\n  \n  // Identifiers and literals\n  IDENTIFIER: 'IDENTIFIER',\n  NUMBER: 'NUMBER',\n  STRING: 'STRING',\n  \n  // Keywords\n  DEF: 'DEF',\n  LET: 'LET',\n  IF: 'IF',\n  ELSE: 'ELSE',\n  WHILE: 'WHILE',\n  RETURN: 'RETURN',\n  TRUE: 'TRUE',\n  FALSE: 'FALSE',\n  NULL: 'NULL',\n  \n  // Operators\n  PLUS: '+',\n  MINUS: '-',\n  ASTERISK: '*',\n  SLASH: '/',\n  PERCENT: '%',\n  \n  // Comparison operators\n  EQ: '==',\n  NOT_EQ: '!=',\n  LT: '<',\n  GT: '>',\n  LT_EQ: '<=',\n  GT_EQ: '>=',\n  \n  // Logical operators\n  AND: '&&',\n  OR: '||',\n  NOT: '!',\n  \n  // Assignment\n  ASSIGN: '=',\n  \n  // Delimiters\n  COMMA: ',',\n  SEMICOLON: ';',\n  LPAREN: '(',\n  RPAREN: ')',\n  LBRACE: '{',\n  RBRACE: '}',\n  \n  // Member access\n  DOT: '.',\n  \n  // Array access\n  LBRACKET: '[',\n  RBRACKET: ']',\n};\n\n/**\n * Keywords mapping for the language\n */\nexport const Keywords = {\n  'def': TokenType.DEF,\n  'let': TokenType.LET,\n  'if': TokenType.IF,\n  'else': TokenType.ELSE,\n  'while': TokenType.WHILE,\n  'return': TokenType.RETURN,\n  'true': TokenType.TRUE,\n  'false': TokenType.FALSE,\n  'null': TokenType.NULL,\n};\n\n/**\n * Token class to represent a lexical token\n */\nexport class Token {\n  constructor(type, literal, line, column) {\n    this.type = type;\n    this.literal = literal;\n    this.line = line;\n    this.column = column;\n  }\n  \n  toString() {\n    return `Token(${this.type}, '${this.literal}', ${this.line}:${this.column})`;\n  }\n} ","import { TokenType, Keywords, Token } from './tokens.js';\n\n/**\n * Lexer class to tokenize the input source code\n * Following the KISS principle: Simple, straightforward lexical analysis\n */\nexport class Lexer {\n  constructor(input) {\n    this.input = input;\n    this.position = 0;      // Current position in input (points to current character)\n    this.readPosition = 0;  // Next position in input (after current character)\n    this.ch = '';           // Current character under examination\n    this.line = 1;          // Current line number\n    this.column = 0;        // Current column number\n    \n    this.readChar(); // Initialize first character\n  }\n  \n  /**\n   * Advances to the next character in the input\n   */\n  readChar() {\n    if (this.readPosition >= this.input.length) {\n      this.ch = ''; // EOF\n    } else {\n      this.ch = this.input[this.readPosition];\n    }\n    \n    this.position = this.readPosition;\n    this.readPosition += 1;\n    this.column += 1;\n  }\n  \n  /**\n   * Peeks at the next character without advancing\n   */\n  peekChar() {\n    if (this.readPosition >= this.input.length) {\n      return ''; // EOF\n    } else {\n      return this.input[this.readPosition];\n    }\n  }\n  \n  /**\n   * Reads the next token from the input\n   */\n  nextToken() {\n    let token;\n    \n    this.skipWhitespace();\n    this.skipComments();\n    \n    switch (this.ch) {\n      case '=':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.ASSIGN, this.ch, this.line, this.column);\n        }\n        break;\n      case '+':\n        token = new Token(TokenType.PLUS, this.ch, this.line, this.column);\n        break;\n      case '-':\n        token = new Token(TokenType.MINUS, this.ch, this.line, this.column);\n        break;\n      case '*':\n        token = new Token(TokenType.ASTERISK, this.ch, this.line, this.column);\n        break;\n      case '#':\n        this.skipComments();\n        return this.nextToken();\n      case '/':\n        if (this.peekChar() === '/' || this.peekChar() === '*') {\n          this.skipComments();\n          return this.nextToken();\n        } else {\n          token = new Token(TokenType.SLASH, this.ch, this.line, this.column);\n        }\n        break;\n      case '%':\n        token = new Token(TokenType.PERCENT, this.ch, this.line, this.column);\n        break;\n      case '!':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.NOT_EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.NOT, this.ch, this.line, this.column);\n        }\n        break;\n      case '<':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.LT_EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.LT, this.ch, this.line, this.column);\n        }\n        break;\n      case '>':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.GT_EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.GT, this.ch, this.line, this.column);\n        }\n        break;\n      case '&':\n        if (this.peekChar() === '&') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.AND, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.ILLEGAL, this.ch, this.line, this.column);\n        }\n        break;\n      case '|':\n        if (this.peekChar() === '|') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.OR, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.ILLEGAL, this.ch, this.line, this.column);\n        }\n        break;\n      case ',':\n        token = new Token(TokenType.COMMA, this.ch, this.line, this.column);\n        break;\n      case ';':\n        token = new Token(TokenType.SEMICOLON, this.ch, this.line, this.column);\n        break;\n      case '.':\n        token = new Token(TokenType.DOT, this.ch, this.line, this.column);\n        break;\n      case '(':\n        token = new Token(TokenType.LPAREN, this.ch, this.line, this.column);\n        break;\n      case ')':\n        token = new Token(TokenType.RPAREN, this.ch, this.line, this.column);\n        break;\n      case '{':\n        token = new Token(TokenType.LBRACE, this.ch, this.line, this.column);\n        break;\n      case '}':\n        token = new Token(TokenType.RBRACE, this.ch, this.line, this.column);\n        break;\n      case '\"':\n      case \"'\":\n        const startColumn = this.column;\n        const stringLiteral = this.readString(this.ch);\n        token = new Token(TokenType.STRING, stringLiteral, this.line, startColumn);\n        break;\n      case '':\n        token = new Token(TokenType.EOF, '', this.line, this.column);\n        break;\n      case '[':\n        token = new Token(TokenType.LBRACKET, this.ch, this.line, this.column);\n        break;\n      case ']':\n        token = new Token(TokenType.RBRACKET, this.ch, this.line, this.column);\n        break;\n      default:\n        if (this.isLetter(this.ch)) {\n          const startColumn = this.column;\n          const identifier = this.readIdentifier();\n          const type = Keywords[identifier] || TokenType.IDENTIFIER;\n          token = new Token(type, identifier, this.line, startColumn);\n          return token;\n        } else if (this.isDigit(this.ch)) {\n          const startColumn = this.column;\n          const number = this.readNumber();\n          token = new Token(TokenType.NUMBER, number, this.line, startColumn);\n          return token;\n        } else {\n          token = new Token(TokenType.ILLEGAL, this.ch, this.line, this.column);\n        }\n    }\n    \n    this.readChar();\n    return token;\n  }\n  \n  /**\n   * Reads an identifier from the input\n   */\n  readIdentifier() {\n    const position = this.position;\n    while (this.isLetter(this.ch) || this.isDigit(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  \n  /**\n   * Reads a number from the input (integers and floats)\n   */\n  readNumber() {\n    const position = this.position;\n    \n    // Read integer part\n    while (this.isDigit(this.ch)) {\n      this.readChar();\n    }\n    \n    // Check for decimal point\n    if (this.ch === '.' && this.isDigit(this.peekChar())) {\n      this.readChar(); // consume the decimal point\n      \n      // Read decimal part\n      while (this.isDigit(this.ch)) {\n        this.readChar();\n      }\n    }\n    \n    return this.input.slice(position, this.position);\n  }\n  \n  /**\n   * Reads a string literal from the input\n   */\n  readString(quote) {\n    this.readChar(); // Skip the opening quote\n    const position = this.position;\n    \n    while (this.ch !== quote && this.ch !== '') {\n      // Handle escape sequences\n      if (this.ch === '\\\\' && (this.peekChar() === quote || this.peekChar() === '\\\\')) {\n        this.readChar(); // Skip the backslash\n      }\n      \n      // Handle newline in string\n      if (this.ch === '\\n') {\n        this.line++;\n        this.column = 0;\n      }\n      \n      this.readChar();\n    }\n    \n    const str = this.input.slice(position, this.position);\n    return str;\n  }\n  \n  /**\n   * Skips whitespace characters\n   */\n  skipWhitespace() {\n    while (this.ch === ' ' || this.ch === '\\t' || this.ch === '\\r' || this.ch === '\\n') {\n      if (this.ch === '\\n') {\n        this.line++;\n        this.column = 0;\n      }\n      this.readChar();\n    }\n  }\n  \n  /**\n   * Skips comments (both single-line and multi-line)\n   */\n  skipComments() {\n    if (this.ch === '#' || this.ch === '/' && this.peekChar() === '/') {\n      // Single-line comment\n      while (this.ch !== '\\n' && this.ch !== '') {\n        this.readChar();\n      }\n      this.skipWhitespace();\n    } else if (this.ch === '/' && this.peekChar() === '*') {\n      // Multi-line comment\n      this.readChar(); // Skip the first /\n      this.readChar(); // Skip the *\n      \n      let commentEnd = false;\n      while (!commentEnd && this.ch !== '') {\n        if (this.ch === '*' && this.peekChar() === '/') {\n          commentEnd = true;\n          this.readChar(); // Skip the *\n          this.readChar(); // Skip the /\n        } else {\n          if (this.ch === '\\n') {\n            this.line++;\n            this.column = 0;\n          }\n          this.readChar();\n        }\n      }\n      \n      this.skipWhitespace();\n    }\n  }\n  \n  /**\n   * Checks if a character is a letter (a-z, A-Z, _)\n   */\n  isLetter(ch) {\n    return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || ch === '_';\n  }\n  \n  /**\n   * Checks if a character is a digit (0-9)\n   */\n  isDigit(ch) {\n    return '0' <= ch && ch <= '9';\n  }\n  \n  /**\n   * Tokenizes the entire input and returns an array of tokens\n   */\n  tokenize() {\n    const tokens = [];\n    let token = this.nextToken();\n    \n    while (token.type !== TokenType.EOF) {\n      tokens.push(token);\n      token = this.nextToken();\n    }\n    \n    tokens.push(token); // Add EOF token\n    return tokens;\n  }\n} ","/**\n * Runtime environment for the interpreter\n * Manages scope, variables, functions, and error handling\n */\n\n// Return value object used for function returns and control flow\nexport class ReturnValue {\n  constructor(value) {\n    this.value = value;\n  }\n}\n\n// Built-in library function type\nexport class LibraryFunction {\n  constructor(name, jsFunction, isAsync = false) {\n    this.name = name;\n    this.implementation = jsFunction;\n    this.isAsync = isAsync;\n  }\n}\n\n// Runtime error with position information\nexport class RuntimeError extends Error {\n  constructor(message, line, column) {\n    super(message);\n    this.line = line || 0;\n    this.column = column || 0;\n    this.name = 'RuntimeError';\n  }\n}\n\n// Environment to store variables and functions in the current scope\nexport class Environment {\n  constructor(parent = null) {\n    this.parent = parent;\n    this.values = new Map();\n    this.libraryFunctions = new Map();\n  }\n\n  // Create a new nested scope\n  extend() {\n    return new Environment(this);\n  }\n\n  // Define a variable in the current scope\n  define(name, value) {\n    this.values.set(name, value);\n    return value;\n  }\n\n  // Get a variable from the current or parent scopes\n  get(name, position) {\n    if (this.values.has(name)) {\n      return this.values.get(name);\n    }\n\n    // Check if it's a library function\n    if (this.libraryFunctions.has(name)) {\n      return this.libraryFunctions.get(name);\n    }\n\n    // Look in parent scope\n    if (this.parent) {\n      return this.parent.get(name, position);\n    }\n\n    throw new RuntimeError(`Undefined variable '${name}'`, position?.line, position?.column);\n  }\n\n  // Set a variable in the current or parent scopes\n  assign(name, value, position) {\n    if (this.values.has(name)) {\n      this.values.set(name, value);\n      return value;\n    }\n\n    // Try to assign in parent scope\n    if (this.parent) {\n      return this.parent.assign(name, value, position);\n    }\n\n    throw new RuntimeError(`Cannot assign to undefined variable '${name}'`, position?.line, position?.column);\n  }\n\n  // Register a library function\n  registerLibraryFunction(name, implementation, isAsync = false) {\n    const libraryFunction = new LibraryFunction(name, implementation, isAsync);\n    this.libraryFunctions.set(name, libraryFunction);\n    return libraryFunction;\n  }\n}\n\n/**\n * Evaluation context for the interpreter\n * \n * This class manages the execution environment for the interpreter,\n * including variables, functions, JSON data, and console output.\n */\nexport class EvaluationContext {\n  /**\n   * Create a new evaluation context with the given data\n   * \n   * @param {Object} jsonData - The initial JSON data object\n   * @param {Array} consoleOutput - The array to collect console output\n   */\n  constructor(jsonData = {}, consoleOutput = []) {\n    // Execution context variables (user-defined)\n    this.variables = {};\n    // JSON data for I/O operations (external data)\n    this.jsonData = jsonData;\n    // Console output buffer for logging\n    this.consoleOutput = consoleOutput;\n    // Library functions (built-in and user-registered)\n    this.functions = {};\n    // Track which functions are async\n    this.asyncFunctions = new Set();\n    // Create environment for scoped variables\n    this.environment = new Environment();\n  }\n\n  /**\n   * Get the current environment\n   * @returns {Environment} The current environment\n   */\n  getEnvironment() {\n    return this.environment;\n  }\n\n  /**\n   * Convert a value to a string for display\n   * @param {*} value - The value to stringify\n   * @returns {string} The string representation\n   */\n  stringify(value) {\n    if (value === null) return 'null';\n    if (value === undefined) return 'undefined';\n    if (typeof value === 'object') return JSON.stringify(value);\n    return String(value);\n  }\n\n  /**\n   * Lookup a variable value from the context\n   * @param {string} name - The variable name\n   * @returns {*} The variable value\n   * @throws {Error} If the variable is not defined\n   */\n  lookupVariable(name) {\n    // First check variables\n    if (name in this.variables) {\n      return this.variables[name];\n    }\n    \n    // Then check functions (for function calls)\n    if (name in this.functions) {\n      return this.functions[name];\n    }\n    \n    // Finally check environment\n    try {\n      if (this.environment) {\n        return this.environment.get(name);\n      }\n    } catch (e) {\n      // Don't throw here, we'll throw our own error below\n    }\n    \n    // If we get here, the variable wasn't found\n    throw new RuntimeError(\n      `Undefined variable '${name}'`,\n      0,\n      0\n    );\n  }\n\n  /**\n   * Assign a value to a variable in the context\n   * @param {string} name - The variable name\n   * @param {*} value - The value to assign\n   * @returns {*} The assigned value\n   */\n  assignVariable(name, value) {\n    this.variables[name] = value;\n    return value;\n  }\n\n  /**\n   * Lookup a function from the context\n   * @param {string} name - The function name\n   * @returns {Function|null} The function or null if not found\n   */\n  lookupFunction(name) {\n    if (name in this.functions) {\n      return this.functions[name];\n    }\n    return null;\n  }\n\n  /**\n   * Check if a function is async\n   * @param {string} name - The function name\n   * @returns {boolean} True if the function is async\n   */\n  isAsyncFunction(name) {\n    return this.asyncFunctions.has(name);\n  }\n\n  /**\n   * Register a function in the context\n   * @param {string} name - The function name\n   * @param {Function} func - The function implementation\n   * @param {boolean} isAsync - Whether the function is asynchronous\n   * @returns {Function} The wrapped function\n   */\n  registerFunction(name, func, isAsync = false) {\n    // Wrap the function to ensure proper argument handling\n    const wrappedFunc = (...args) => {\n      // Special handling for array arguments\n      if (args.length === 1 && Array.isArray(args[0])) {\n        // If there's only one argument and it's an array, it could be:\n        // 1. An actual array parameter from the script\n        // 2. The arguments array from a CallExpression\n        \n        // Check if this array contains arrays or objects that appear to be AST nodes\n        const isArgArray = args[0].some(item => \n          (typeof item === 'object' && item !== null && \n           (item.type || Array.isArray(item)))\n        );\n        \n        if (isArgArray) {\n          // This is likely an arguments array, so pass it to the function\n          return func(...args[0]);\n        } else {\n          // This is likely an actual array parameter, pass it directly\n          return func(args[0]);\n        }\n      }\n      \n      // Otherwise pass all arguments directly\n      return func(...args);\n    };\n    \n    this.functions[name] = wrappedFunc;\n    \n    // Mark as async if needed\n    if (isAsync) {\n      this.asyncFunctions.add(name);\n    }\n    \n    return wrappedFunc;\n  }\n\n  /**\n   * Get a value from the JSON data by key\n   * @param {string} key - The key to lookup\n   * @returns {*} The value or null if not found\n   */\n  io_get(key) {\n    if (key in this.jsonData) {\n      const value = this.jsonData[key];\n      \n      // If it's an array, make a copy to prevent modification of the original\n      if (Array.isArray(value)) {\n        return [...value];\n      }\n      \n      return value;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Put a value into the JSON data by key\n   * \n   * This method handles two calling conventions:\n   * 1. io_put(key, value) - Direct call with two arguments\n   * 2. io_put([key, value]) - Call with arguments as an array (from CallExpression)\n   * \n   * @param {string|Array} key - The key or [key, value] array\n   * @param {*} value - The value (optional if key is an array)\n   * @returns {*} The stored value\n   */\n  io_put(key, value) {\n    let actualKey, actualValue;\n    \n    // Handle both calling conventions\n    if (Array.isArray(key) && value === undefined) {\n      // Called as io_put([key, value]) from CallExpression\n      [actualKey, actualValue] = key;\n    } else {\n      // Called as io_put(key, value) directly\n      actualKey = key;\n      actualValue = value;\n    }\n    \n    this.jsonData[actualKey] = actualValue;\n    return actualValue;\n  }\n\n  /**\n   * Output a value to the console\n   * @param {*} value - The value to output\n   * @returns {*} The original value\n   */\n  console_put(value) {\n    // Handle array case from CallExpression\n    const actualValue = Array.isArray(value) && value.length === 1 ? value[0] : value;\n    \n    // Convert to string and add to console output\n    this.consoleOutput.push(this.stringify(actualValue));\n    \n    return actualValue;\n  }\n\n  /**\n   * Create a child context for a function call\n   * @returns {EvaluationContext} A new child context\n   */\n  createChildContext() {\n    const childContext = new EvaluationContext(this.jsonData, this.consoleOutput);\n    \n    // Copy registered functions\n    Object.keys(this.functions).forEach(key => {\n      childContext.functions[key] = this.functions[key];\n      \n      if (this.asyncFunctions.has(key)) {\n        childContext.asyncFunctions.add(key);\n      }\n    });\n    \n    return childContext;\n  }\n} ","/**\n * Abstract Syntax Tree (AST) node classes for our language\n * Following Niklaus Wirth's approach of simple, clear node structures\n */\n\nimport { ReturnValue, RuntimeError, LibraryFunction } from './runtime.js';\n\n// Base Node class\nexport class Node {\n  constructor() {\n    this.position = { line: 0, column: 0 };\n  }\n  \n  // For debugging - by default return the constructor name\n  toString() {\n    return this.constructor.name;\n  }\n  \n  // Return a JSON representation of the node for AST visualization\n  toJSON() {\n    return {\n      type: this.constructor.name,\n      ...this\n    };\n  }\n  \n  // Base evaluate method - should be overridden by derived classes\n  async evaluate(context) {\n    throw new Error(`${this.constructor.name} does not implement evaluate()`);\n  }\n}\n\n// Program is the root node of every AST\nexport class Program extends Node {\n  constructor() {\n    super();\n    this.statements = [];\n  }\n  \n  toJSON() {\n    return {\n      type: 'Program',\n      statements: this.statements.map(stmt => stmt.toJSON())\n    };\n  }\n  \n  async evaluate(context) {\n    let result = null;\n    \n    for (const statement of this.statements) {\n      result = await statement.evaluate(context);\n      \n      // Early return if we hit a return statement\n      if (result instanceof ReturnValue) {\n        return result.value;\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Statement nodes\n\nexport class BlockStatement extends Node {\n  constructor() {\n    super();\n    this.statements = [];\n  }\n  \n  toJSON() {\n    return {\n      type: 'BlockStatement',\n      position: this.position,\n      statements: this.statements.map(stmt => stmt.toJSON())\n    };\n  }\n  \n  async evaluate(context) {\n    let result = null;\n    \n    for (const statement of this.statements) {\n      result = await statement.evaluate(context);\n      \n      // Early return from blocks if we hit a return statement\n      if (result instanceof ReturnValue) {\n        return result;\n      }\n    }\n    \n    return result;\n  }\n}\n\nexport class ExpressionStatement extends Node {\n  constructor(expression) {\n    super();\n    this.expression = expression;\n  }\n  \n  toJSON() {\n    return {\n      type: 'ExpressionStatement',\n      position: this.position,\n      expression: this.expression ? this.expression.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    return await this.expression.evaluate(context);\n  }\n}\n\nexport class VariableDeclaration extends Node {\n  constructor(name, initializer) {\n    super();\n    this.name = name;\n    this.initializer = initializer;\n  }\n  \n  toJSON() {\n    return {\n      type: 'VariableDeclaration',\n      position: this.position,\n      name: this.name,\n      initializer: this.initializer ? this.initializer.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const value = this.initializer ? await this.initializer.evaluate(context) : null;\n    return context.getEnvironment().define(this.name, value);\n  }\n}\n\nexport class AssignmentStatement extends Node {\n  constructor(name, value) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'AssignmentStatement',\n      position: this.position,\n      name: this.name,\n      value: this.value ? this.value.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const value = await this.value.evaluate(context);\n    return context.getEnvironment().assign(this.name, value, this.position);\n  }\n}\n\nexport class FunctionDeclaration extends Node {\n  constructor(name, parameters, body) {\n    super();\n    this.name = name;\n    this.parameters = parameters || [];\n    this.body = body;\n  }\n  \n  toJSON() {\n    return {\n      type: 'FunctionDeclaration',\n      position: this.position,\n      name: this.name,\n      parameters: this.parameters,\n      body: this.body ? this.body.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const func = async (args) => {\n      // Create a new environment with the parent as the current environment\n      const functionEnv = context.getEnvironment().extend();\n      \n      // Bind arguments to parameters\n      for (let i = 0; i < this.parameters.length; i++) {\n        const param = this.parameters[i];\n        const arg = i < args.length ? args[i] : null;\n        \n        functionEnv.define(param, arg);\n      }\n      \n      // Execute the function body with the new environment\n      const previousEnv = context.environment;\n      context.environment = functionEnv;\n      \n      let result;\n      try {\n        result = await this.body.evaluate(context);\n      } finally {\n        // Restore the original environment\n        context.environment = previousEnv;\n      }\n      \n      // Unwrap ReturnValue if present\n      if (result instanceof ReturnValue) {\n        return result.value;\n      }\n      \n      return result;\n    };\n    \n    // Store the function in the environment\n    return context.getEnvironment().define(this.name, func);\n  }\n}\n\nexport class ReturnStatement extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'ReturnStatement',\n      position: this.position,\n      value: this.value ? this.value.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const value = this.value ? await this.value.evaluate(context) : null;\n    return new ReturnValue(value);\n  }\n}\n\nexport class IfStatement extends Node {\n  constructor(condition, consequence, alternative) {\n    super();\n    this.condition = condition;\n    this.consequence = consequence;\n    this.alternative = alternative;\n  }\n  \n  toJSON() {\n    return {\n      type: 'IfStatement',\n      position: this.position,\n      condition: this.condition ? this.condition.toJSON() : null,\n      consequence: this.consequence ? this.consequence.toJSON() : null,\n      alternative: this.alternative ? this.alternative.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const condition = await this.condition.evaluate(context);\n    \n    if (isTruthy(condition)) {\n      return await this.consequence.evaluate(context);\n    } else if (this.alternative) {\n      return await this.alternative.evaluate(context);\n    }\n    \n    return null;\n  }\n}\n\nexport class WhileStatement extends Node {\n  constructor(condition, body) {\n    super();\n    this.condition = condition;\n    this.body = body;\n  }\n  \n  toJSON() {\n    return {\n      type: 'WhileStatement',\n      position: this.position,\n      condition: this.condition ? this.condition.toJSON() : null,\n      body: this.body ? this.body.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    let result = null;\n    \n    while (isTruthy(await this.condition.evaluate(context))) {\n      result = await this.body.evaluate(context);\n      \n      // Handle return statements inside the loop\n      if (result instanceof ReturnValue) {\n        return result;\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Expression nodes\n\nexport class Identifier extends Node {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  \n  toJSON() {\n    return {\n      type: 'Identifier',\n      position: this.position,\n      name: this.name\n    };\n  }\n  \n  async evaluate(context) {\n    try {\n      // First try to look up via the context's lookupVariable method\n      // which also checks for functions\n      return context.lookupVariable(this.name);\n    } catch (error) {\n      // If that fails, fall back to environment if it exists\n      try {\n        if (context.getEnvironment) {\n          return context.getEnvironment().get(this.name, this.position);\n        }\n      } catch (envError) {\n        // Ignore environment error, we'll throw our own below\n      }\n      \n      throw new RuntimeError(\n        `Undefined variable '${this.name}'`,\n        this.position.line,\n        this.position.column\n      );\n    }\n  }\n}\n\nexport class NumberLiteral extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'NumberLiteral',\n      position: this.position,\n      value: this.value\n    };\n  }\n  \n  async evaluate(context) {\n    return this.value;\n  }\n}\n\nexport class StringLiteral extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'StringLiteral',\n      position: this.position,\n      value: this.value\n    };\n  }\n  \n  async evaluate(context) {\n    return this.value;\n  }\n}\n\nexport class BooleanLiteral extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'BooleanLiteral',\n      position: this.position,\n      value: this.value\n    };\n  }\n  \n  async evaluate(context) {\n    return this.value;\n  }\n}\n\nexport class NullLiteral extends Node {\n  constructor() {\n    super();\n  }\n  \n  toJSON() {\n    return {\n      type: 'NullLiteral',\n      position: this.position\n    };\n  }\n  \n  async evaluate(context) {\n    return null;\n  }\n}\n\nexport class PrefixExpression extends Node {\n  constructor(operator, right) {\n    super();\n    this.operator = operator;\n    this.right = right;\n  }\n  \n  toJSON() {\n    return {\n      type: 'PrefixExpression',\n      position: this.position,\n      operator: this.operator,\n      right: this.right ? this.right.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const right = await this.right.evaluate(context);\n    \n    switch (this.operator) {\n      case '-':\n        return -right;\n      case '!':\n        return !isTruthy(right);\n      default:\n        throw new RuntimeError(\n          `Unknown prefix operator: ${this.operator}`,\n          this.position.line,\n          this.position.column\n        );\n    }\n  }\n}\n\nexport class InfixExpression extends Node {\n  constructor(left, operator, right) {\n    super();\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  \n  toJSON() {\n    return {\n      type: 'InfixExpression',\n      position: this.position,\n      left: this.left ? this.left.toJSON() : null,\n      operator: this.operator,\n      right: this.right ? this.right.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const left = await this.left.evaluate(context);\n    \n    // Short-circuit for logical operators\n    if (this.operator === '&&') {\n      return isTruthy(left) ? await this.right.evaluate(context) : left;\n    }\n    \n    if (this.operator === '||') {\n      return isTruthy(left) ? left : await this.right.evaluate(context);\n    }\n    \n    const right = await this.right.evaluate(context);\n    \n    switch (this.operator) {\n      case '+':\n        // Handle string concatenation\n        if (typeof left === 'string' || typeof right === 'string') {\n          return String(left) + String(right);\n        }\n        return left + right;\n      \n      case '-':\n        return left - right;\n      \n      case '*':\n        return left * right;\n      \n      case '/':\n        if (right === 0) {\n          throw new RuntimeError(\n            'Division by zero',\n            this.position.line,\n            this.position.column\n          );\n        }\n        return left / right;\n      \n      case '%':\n        if (right === 0) {\n          throw new RuntimeError(\n            'Modulo by zero',\n            this.position.line,\n            this.position.column\n          );\n        }\n        return left % right;\n      \n      case '<':\n        return left < right;\n      \n      case '>':\n        return left > right;\n      \n      case '<=':\n        return left <= right;\n      \n      case '>=':\n        return left >= right;\n      \n      case '==':\n        return left === right;\n      \n      case '!=':\n        return left !== right;\n      \n      default:\n        throw new RuntimeError(\n          `Unknown infix operator: ${this.operator}`,\n          this.position.line,\n          this.position.column\n        );\n    }\n  }\n}\n\nexport class CallExpression extends Node {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.arguments = args || [];\n  }\n  \n  toJSON() {\n    return {\n      type: 'CallExpression',\n      callee: this.callee ? this.callee.toJSON() : null,\n      arguments: this.arguments.map(arg => arg.toJSON())\n    };\n  }\n  \n  async evaluate(context) {\n    // First, evaluate the arguments\n    const args = [];\n    for (const arg of this.arguments) {\n      try {\n        const value = await arg.evaluate(context);\n        args.push(value);\n      } catch (error) {\n        throw error;\n      }\n    }\n    \n    // Then evaluate the callee\n    let callee;\n    try {\n      callee = await this.callee.evaluate(context);\n    } catch (error) {\n      throw error;\n    }\n    \n    // Check if it's a library function\n    if (callee instanceof LibraryFunction) {\n      // Handle async library functions\n      if (callee.isAsync) {\n        return await callee.implementation(...args);\n      } else {\n        // Keep backward compatibility with sync library functions\n        return callee.implementation(...args);\n      }\n    }\n    \n    // Check if it's a user-defined function\n    if (typeof callee === 'function') {\n      // Check if this is an async function\n      const funcName = this.callee.name; // Assuming callee is an Identifier\n      if (funcName && context.isAsyncFunction && context.isAsyncFunction(funcName)) {\n        // User defined async functions expect args as a single array\n        return await callee(args);\n      } else {\n        // User defined functions in this interpreter expect args as a single array\n        // and we want to make sure arrays inside args aren't nested unnecessarily\n        return callee(args);\n      }\n    }\n    \n    throw new RuntimeError(\n      `Cannot call non-function: ${context.stringify(callee)}`,\n      this.position.line,\n      this.position.column\n    );\n  }\n}\n\nexport class MemberExpression extends Node {\n  constructor(object, property, computed = false) {\n    super();\n    this.object = object;       // The object being accessed\n    this.property = property;   // The property being accessed\n    this.computed = computed;   // Whether this is computed access e.g. obj[expr] (true) or obj.prop (false)\n  }\n  \n  toJSON() {\n    return {\n      type: 'MemberExpression',\n      position: this.position,\n      object: this.object ? this.object.toJSON() : null,\n      property: this.property ? this.property.toJSON() : null,\n      computed: this.computed\n    };\n  }\n  \n  async evaluate(context) {\n    const object = await this.object.evaluate(context);\n    let property;\n    \n    if (this.computed) {\n      // Computed member access: obj[expr]\n      property = await this.property.evaluate(context);\n    } else {\n      // Static member access: obj.prop\n      property = this.property.name;\n    }\n    \n    if (object === null || object === undefined) {\n      throw new Error('Cannot access property of null or undefined');\n    }\n    \n    return object[property];\n  }\n}\n\nexport class ArrayLiteral extends Node {\n  constructor(elements = []) {\n    super();\n    this.elements = elements;\n  }\n  \n  toJSON() {\n    return {\n      type: 'ArrayLiteral',\n      position: this.position,\n      elements: this.elements.map(e => e ? e.toJSON() : null)\n    };\n  }\n  \n  async evaluate(context) {\n    const result = [];\n    for (const element of this.elements) {\n      result.push(await element.evaluate(context));\n    }\n    return result;\n  }\n}\n\n// Helper function to determine if a value is truthy\nfunction isTruthy(value) {\n  if (value === null) return false;\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'number') return value !== 0;\n  if (typeof value === 'string') return value.length > 0;\n  return true;\n} ","import { TokenType } from './tokens.js';\nimport * as AST from './ast.js';\n\n/**\n * Precedence levels for operators\n */\nconst PRECEDENCE = {\n  LOWEST: 1,\n  OR: 2,      // ||\n  AND: 3,     // &&\n  EQUALS: 4,  // == !=\n  COMPARE: 5, // > >= < <=\n  SUM: 6,     // + -\n  PRODUCT: 7, // * / %\n  PREFIX: 8,  // -x !x\n  CALL: 9,    // myFunction(x)\n  MEMBER: 10, // obj.property\n};\n\n// Mapping of token types to their respective precedence\nconst PRECEDENCES = {\n  [TokenType.OR]: PRECEDENCE.OR,\n  [TokenType.AND]: PRECEDENCE.AND,\n  [TokenType.EQ]: PRECEDENCE.EQUALS,\n  [TokenType.NOT_EQ]: PRECEDENCE.EQUALS,\n  [TokenType.LT]: PRECEDENCE.COMPARE,\n  [TokenType.GT]: PRECEDENCE.COMPARE,\n  [TokenType.LT_EQ]: PRECEDENCE.COMPARE,\n  [TokenType.GT_EQ]: PRECEDENCE.COMPARE,\n  [TokenType.PLUS]: PRECEDENCE.SUM,\n  [TokenType.MINUS]: PRECEDENCE.SUM,\n  [TokenType.ASTERISK]: PRECEDENCE.PRODUCT,\n  [TokenType.SLASH]: PRECEDENCE.PRODUCT,\n  [TokenType.PERCENT]: PRECEDENCE.PRODUCT,\n  [TokenType.LPAREN]: PRECEDENCE.CALL,\n  [TokenType.DOT]: PRECEDENCE.MEMBER,\n  [TokenType.LBRACKET]: PRECEDENCE.MEMBER,\n};\n\n/**\n * Parser class for converting tokens into an AST\n * Implementation of a predictive recursive descent parser (LL(1))\n * as described in Wirth's \"Compilerbau\" (Compiler Construction)\n */\nexport class Parser {\n  constructor(lexer) {\n    this.lexer = lexer;\n    this.tokens = [];\n    this.currentPosition = 0;\n    this.errors = [];\n    \n    // Initialize with next two tokens\n    this.nextToken();\n    this.nextToken();\n    \n    // Register parsing functions for different types of expressions\n    this.prefixParseFns = new Map();\n    this.infixParseFns = new Map();\n    \n    // Register prefix parsers\n    this.registerPrefix(TokenType.IDENTIFIER, this.parseIdentifier.bind(this));\n    this.registerPrefix(TokenType.NUMBER, this.parseNumberLiteral.bind(this));\n    this.registerPrefix(TokenType.STRING, this.parseStringLiteral.bind(this));\n    this.registerPrefix(TokenType.TRUE, this.parseBooleanLiteral.bind(this));\n    this.registerPrefix(TokenType.FALSE, this.parseBooleanLiteral.bind(this));\n    this.registerPrefix(TokenType.NULL, this.parseNullLiteral.bind(this));\n    this.registerPrefix(TokenType.LPAREN, this.parseGroupedExpression.bind(this));\n    this.registerPrefix(TokenType.MINUS, this.parsePrefixExpression.bind(this));\n    this.registerPrefix(TokenType.NOT, this.parsePrefixExpression.bind(this));\n    this.registerPrefix(TokenType.LBRACKET, this.parseArrayLiteral.bind(this));\n    \n    // Register infix parsers\n    this.registerInfix(TokenType.PLUS, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.MINUS, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.ASTERISK, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.SLASH, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.PERCENT, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.NOT_EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.LT, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.GT, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.LT_EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.GT_EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.AND, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.OR, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.LPAREN, this.parseCallExpression.bind(this));\n    this.registerInfix(TokenType.DOT, this.parseMemberExpression.bind(this));\n    this.registerInfix(TokenType.LBRACKET, this.parseIndexExpression.bind(this));\n  }\n  \n  /**\n   * Parse the entire program\n   */\n  parseProgram() {\n    const program = new AST.Program();\n    \n    while (!this.currentTokenIs(TokenType.EOF)) {\n      const stmt = this.parseStatement();\n      if (stmt) {\n        program.statements.push(stmt);\n      }\n      this.nextToken();\n    }\n    \n    return program;\n  }\n  \n  /**\n   * Register a prefix parse function\n   */\n  registerPrefix(tokenType, fn) {\n    this.prefixParseFns.set(tokenType, fn);\n  }\n  \n  /**\n   * Register an infix parse function\n   */\n  registerInfix(tokenType, fn) {\n    this.infixParseFns.set(tokenType, fn);\n  }\n  \n  /**\n   * Advance to the next token\n   */\n  nextToken() {\n    this.currentToken = this.peekToken;\n    \n    if (this.currentPosition < this.tokens.length) {\n      this.peekToken = this.tokens[this.currentPosition];\n      this.currentPosition++;\n    } else {\n      const nextToken = this.lexer.nextToken();\n      this.tokens.push(nextToken);\n      this.peekToken = nextToken;\n      this.currentPosition++;\n    }\n  }\n  \n  /**\n   * Check if the current token is of the given type\n   */\n  currentTokenIs(tokenType) {\n    return this.currentToken && this.currentToken.type === tokenType;\n  }\n  \n  /**\n   * Check if the next token is of the given type\n   */\n  peekTokenIs(tokenType) {\n    return this.peekToken && this.peekToken.type === tokenType;\n  }\n  \n  /**\n   * Expect the next token to be of the given type, and advance if it is\n   */\n  expectPeek(tokenType) {\n    if (this.peekTokenIs(tokenType)) {\n      this.nextToken();\n      return true;\n    } else {\n      this.peekError(tokenType);\n      return false;\n    }\n  }\n  \n  /**\n   * Add a peek error\n   */\n  peekError(tokenType) {\n    const msg = `Expected next token to be ${tokenType}, got ${this.peekToken?.type} instead`;\n    this.errors.push({\n      message: msg,\n      line: this.peekToken?.line,\n      column: this.peekToken?.column\n    });\n  }\n  \n  /**\n   * Get the precedence of the next token\n   */\n  peekPrecedence() {\n    return PRECEDENCES[this.peekToken?.type] || PRECEDENCE.LOWEST;\n  }\n  \n  /**\n   * Get the precedence of the current token\n   */\n  currentPrecedence() {\n    return PRECEDENCES[this.currentToken?.type] || PRECEDENCE.LOWEST;\n  }\n  \n  /**\n   * Parse a statement\n   */\n  parseStatement() {\n    switch (this.currentToken.type) {\n      case TokenType.DEF:\n        return this.parseFunctionDeclaration();\n      case TokenType.LET:\n        return this.parseVariableDeclaration();\n      case TokenType.IF:\n        return this.parseIfStatement();\n      case TokenType.WHILE:\n        return this.parseWhileStatement();\n      case TokenType.RETURN:\n        return this.parseReturnStatement();\n      case TokenType.LBRACE:\n        return this.parseBlockStatement();\n      default:\n        // Check for assignment statements (identifier = expression)\n        if (this.currentTokenIs(TokenType.IDENTIFIER) && this.peekTokenIs(TokenType.ASSIGN)) {\n          return this.parseAssignmentStatement();\n        }\n        return this.parseExpressionStatement();\n    }\n  }\n  \n  /**\n   * Parse a block statement\n   */\n  parseBlockStatement() {\n    const block = new AST.BlockStatement();\n    block.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    this.nextToken(); // Skip the opening brace\n    \n    while (!this.currentTokenIs(TokenType.RBRACE) && !this.currentTokenIs(TokenType.EOF)) {\n      const stmt = this.parseStatement();\n      if (stmt) {\n        block.statements.push(stmt);\n      }\n      this.nextToken();\n    }\n    \n    if (!this.currentTokenIs(TokenType.RBRACE)) {\n      this.errors.push({\n        message: \"Expected '}' at the end of block statement\",\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n    }\n    \n    return block;\n  }\n  \n  /**\n   * Parse a function declaration\n   */\n  parseFunctionDeclaration() {\n    const functionDecl = new AST.FunctionDeclaration();\n    functionDecl.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse function name\n    if (!this.expectPeek(TokenType.IDENTIFIER)) {\n      return null;\n    }\n    \n    functionDecl.name = this.currentToken.literal;\n    \n    // Parse parameters\n    if (!this.expectPeek(TokenType.LPAREN)) {\n      return null;\n    }\n    \n    functionDecl.parameters = this.parseFunctionParameters();\n    \n    // Parse function body\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    functionDecl.body = this.parseBlockStatement();\n    \n    return functionDecl;\n  }\n  \n  /**\n   * Parse function parameters\n   */\n  parseFunctionParameters() {\n    const parameters = [];\n    \n    // Empty parameter list\n    if (this.peekTokenIs(TokenType.RPAREN)) {\n      this.nextToken();\n      return parameters;\n    }\n    \n    this.nextToken();\n    \n    // First parameter\n    parameters.push(this.currentToken.literal);\n    \n    // Subsequent parameters\n    while (this.peekTokenIs(TokenType.COMMA)) {\n      this.nextToken(); // Skip comma\n      this.nextToken(); // Move to parameter name\n      \n      if (this.currentTokenIs(TokenType.IDENTIFIER)) {\n        parameters.push(this.currentToken.literal);\n      } else {\n        this.errors.push({\n          message: \"Expected parameter name\",\n          line: this.currentToken?.line,\n          column: this.currentToken?.column\n        });\n      }\n    }\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    return parameters;\n  }\n  \n  /**\n   * Parse a variable declaration\n   */\n  parseVariableDeclaration() {\n    const declaration = new AST.VariableDeclaration();\n    declaration.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse variable name\n    if (!this.expectPeek(TokenType.IDENTIFIER)) {\n      return null;\n    }\n    \n    declaration.name = this.currentToken.literal;\n    \n    // Parse initializer (if any)\n    if (this.peekTokenIs(TokenType.ASSIGN)) {\n      this.nextToken();\n      this.nextToken();\n      declaration.initializer = this.parseExpression(PRECEDENCE.LOWEST);\n    }\n    \n    // Expect semicolon\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    } else {\n      this.errors.push({\n        message: \"Expected ';' after variable declaration\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n    }\n    \n    return declaration;\n  }\n  \n  /**\n   * Parse an assignment statement\n   */\n  parseAssignmentStatement() {\n    const assignment = new AST.AssignmentStatement();\n    assignment.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    assignment.name = this.currentToken.literal;\n    \n    this.nextToken(); // Skip the identifier\n    this.nextToken(); // Skip the '='\n    \n    assignment.value = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    // Expect semicolon\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    } else {\n      this.errors.push({\n        message: \"Expected ';' after assignment\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n    }\n    \n    return assignment;\n  }\n  \n  /**\n   * Parse an assignment expression without requiring a semicolon\n   * This is specifically used in for loop initializers and updates\n   */\n  parseAssignmentExpression() {\n    const assignment = new AST.AssignmentStatement();\n    assignment.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    assignment.name = this.currentToken.literal;\n    \n    this.nextToken(); // Skip the identifier\n    this.nextToken(); // Skip the '='\n    \n    assignment.value = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    // No semicolon expectation here\n    return assignment;\n  }\n  \n  /**\n   * Parse an if statement\n   */\n  parseIfStatement() {\n    const ifStmt = new AST.IfStatement();\n    ifStmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse the condition\n    if (!this.expectPeek(TokenType.LPAREN)) {\n      return null;\n    }\n    \n    this.nextToken(); // Skip the '('\n    ifStmt.condition = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    // Parse the consequence (if block)\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    ifStmt.consequence = this.parseBlockStatement();\n    \n    // Parse the alternative (else block) if it exists\n    if (this.peekTokenIs(TokenType.ELSE)) {\n      this.nextToken();\n      \n      if (this.peekTokenIs(TokenType.IF)) {\n        // This is an \"else if\"\n        this.nextToken();\n        ifStmt.alternative = this.parseIfStatement();\n      } else if (this.peekTokenIs(TokenType.LBRACE)) {\n        // This is a regular \"else\"\n        this.nextToken();\n        ifStmt.alternative = this.parseBlockStatement();\n      } else {\n        this.errors.push({\n          message: \"Expected 'if' or '{' after 'else'\",\n          line: this.peekToken?.line,\n          column: this.peekToken?.column\n        });\n      }\n    }\n    \n    return ifStmt;\n  }\n  \n  /**\n   * Parse a while statement\n   */\n  parseWhileStatement() {\n    const whileStmt = new AST.WhileStatement();\n    whileStmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse condition\n    if (!this.expectPeek(TokenType.LPAREN)) {\n      return null;\n    }\n    \n    this.nextToken(); // Skip the '('\n    whileStmt.condition = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    // Parse loop body\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    whileStmt.body = this.parseBlockStatement();\n    \n    return whileStmt;\n  }\n  \n  /**\n   * Parse a return statement\n   */\n  parseReturnStatement() {\n    const returnStmt = new AST.ReturnStatement();\n    returnStmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    this.nextToken(); // Skip 'return' keyword\n    \n    // Check for expression after return\n    if (!this.currentTokenIs(TokenType.SEMICOLON)) {\n      returnStmt.value = this.parseExpression(PRECEDENCE.LOWEST);\n    }\n    \n    // Expect semicolon\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    } else {\n      this.errors.push({\n        message: \"Expected ';' after return statement\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n    }\n    \n    return returnStmt;\n  }\n  \n  /**\n   * Parse an expression statement\n   */\n  parseExpressionStatement() {\n    const stmt = new AST.ExpressionStatement(this.parseExpression(PRECEDENCE.LOWEST));\n    stmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Expect semicolon (optional)\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    }\n    \n    return stmt;\n  }\n  \n  /**\n   * Parse an expression\n   */\n  parseExpression(precedence) {\n    const prefixFn = this.prefixParseFns.get(this.currentToken.type);\n    \n    if (!prefixFn) {\n      this.errors.push({\n        message: `No prefix parse function for ${this.currentToken.type} found`,\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n      return null;\n    }\n    \n    let leftExp = prefixFn();\n    \n    while (!this.peekTokenIs(TokenType.SEMICOLON) && precedence < this.peekPrecedence()) {\n      const infixFn = this.infixParseFns.get(this.peekToken.type);\n      \n      if (!infixFn) {\n        return leftExp;\n      }\n      \n      this.nextToken();\n      leftExp = infixFn(leftExp);\n    }\n    \n    return leftExp;\n  }\n  \n  /**\n   * Parse an identifier\n   */\n  parseIdentifier() {\n    const identifier = new AST.Identifier(this.currentToken.literal);\n    identifier.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return identifier;\n  }\n  \n  /**\n   * Parse a number literal\n   */\n  parseNumberLiteral() {\n    const number = new AST.NumberLiteral(this.currentToken.literal.includes('.') \n      ? parseFloat(this.currentToken.literal) \n      : parseInt(this.currentToken.literal, 10));\n    number.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return number;\n  }\n  \n  /**\n   * Parse a string literal\n   */\n  parseStringLiteral() {\n    const string = new AST.StringLiteral(this.currentToken.literal);\n    string.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return string;\n  }\n  \n  /**\n   * Parse a boolean literal\n   */\n  parseBooleanLiteral() {\n    const boolean = new AST.BooleanLiteral(this.currentToken.type === TokenType.TRUE);\n    boolean.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return boolean;\n  }\n  \n  /**\n   * Parse a null literal\n   */\n  parseNullLiteral() {\n    const nullLiteral = new AST.NullLiteral();\n    nullLiteral.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return nullLiteral;\n  }\n  \n  /**\n   * Parse a grouped expression (inside parentheses)\n   */\n  parseGroupedExpression() {\n    this.nextToken(); // Skip the '('\n    \n    const exp = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    return exp;\n  }\n  \n  /**\n   * Parse a prefix expression\n   */\n  parsePrefixExpression() {\n    const expression = new AST.PrefixExpression(\n      this.currentToken.literal,\n      null // right expression will be set below\n    );\n    expression.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    this.nextToken();\n    expression.right = this.parseExpression(PRECEDENCE.PREFIX);\n    \n    return expression;\n  }\n  \n  /**\n   * Parse an infix expression\n   */\n  parseInfixExpression(left) {\n    const expression = new AST.InfixExpression(\n      left,\n      this.currentToken.literal,\n      null // right expression will be set below\n    );\n    expression.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    const precedence = this.currentPrecedence();\n    this.nextToken();\n    expression.right = this.parseExpression(precedence);\n    \n    return expression;\n  }\n  \n  /**\n   * Parse a function call expression\n   */\n  parseCallExpression(callee) {\n    const expression = new AST.CallExpression(callee, []);\n    expression.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    expression.arguments = this.parseCallArguments();\n    \n    return expression;\n  }\n  \n  /**\n   * Parse function call arguments\n   */\n  parseCallArguments() {\n    return this.parseExpressionList(TokenType.RPAREN);\n  }\n  \n  /**\n   * Parse a member expression (object.property)\n   */\n  parseMemberExpression(object) {\n    const memberExp = new AST.MemberExpression(\n      object,\n      null, // property will be set below\n      false // not computed\n    );\n    memberExp.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Skip the dot\n    this.nextToken();\n    \n    // Check if the property name is an identifier\n    if (!this.currentTokenIs(TokenType.IDENTIFIER)) {\n      this.errors.push({\n        message: `Expected property name after dot operator, got ${this.currentToken.type}`,\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n      return null;\n    }\n    \n    // Set the property name as an identifier\n    memberExp.property = this.parseIdentifier();\n    \n    return memberExp;\n  }\n  \n  /**\n   * Parse an index expression (object[index])\n   */\n  parseIndexExpression(object) {\n    const indexExp = new AST.MemberExpression(\n      object,\n      null, // property will be set below\n      true  // computed access\n    );\n    indexExp.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Skip the opening bracket\n    this.nextToken();\n    \n    // Parse the index expression\n    indexExp.property = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    // Expect closing bracket\n    if (!this.expectPeek(TokenType.RBRACKET)) {\n      this.errors.push({\n        message: \"Expected ']' after index expression\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n      return null;\n    }\n    \n    return indexExp;\n  }\n  \n  /**\n   * Parse an array literal\n   */\n  parseArrayLiteral() {\n    const array = new AST.ArrayLiteral();\n    array.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    array.elements = this.parseExpressionList(TokenType.RBRACKET);\n    \n    return array;\n  }\n  \n  /**\n   * Parse a list of expressions\n   */\n  parseExpressionList(endToken) {\n    const expressions = [];\n    \n    // Handle empty list\n    if (this.peekTokenIs(endToken)) {\n      this.nextToken();\n      return expressions;\n    }\n    \n    // Skip opening delimiter\n    this.nextToken();\n    \n    // Parse first expression\n    expressions.push(this.parseExpression(PRECEDENCE.LOWEST));\n    \n    // Parse remaining expressions\n    while (this.peekTokenIs(TokenType.COMMA)) {\n      this.nextToken(); // Skip comma\n      this.nextToken(); // Move to next expression\n      expressions.push(this.parseExpression(PRECEDENCE.LOWEST));\n    }\n    \n    // Expect closing delimiter\n    if (!this.expectPeek(endToken)) {\n      return null;\n    }\n    \n    return expressions;\n  }\n} ","import { Lexer } from './lexer.js';\nimport { Parser } from './parser.js';\nimport { EvaluationContext, RuntimeError, ReturnValue } from './runtime.js';\n\n/**\n * Main Interpreter class that orchestrates lexing, parsing, and evaluation of code.\n * This is the primary entry point for using the interpreter.\n */\nexport class Interpreter {\n  /**\n   * Creates a new Interpreter instance with fresh context.\n   * The interpreter provides a clean environment for parsing and evaluating code.\n   * Each parse/evaluate cycle uses its own internal state to prevent side effects\n   * between different code executions.\n   * \n   * @example\n   * ```javascript\n   * const interpreter = new Interpreter();\n   * const parseResult = interpreter.parse('let x = 42;');\n   * if (parseResult.success) {\n   *   const jsonData = {};\n   *   const consoleOutput = [];\n   *   const evalResult = await interpreter.evaluate(jsonData, consoleOutput);\n   *   console.log(evalResult);\n   * }\n   * ```\n   */\n  constructor() {\n    this.ast = null;\n    this.errors = [];\n    // Create evaluation context during initialization\n    this.context = new EvaluationContext();\n    \n    // Register built-in functions\n    this.registerBuiltInFunctions();\n  }\n  \n  /**\n   * Register built-in functions that should be available by default\n   */\n  registerBuiltInFunctions() {\n    // Register console_put and io functions as library functions\n    this.registerFunction('console_put', (value) => {\n      return this.context.console_put(value);\n    });\n    \n    this.registerFunction('io_get', (key) => {\n      return this.context.io_get(key);\n    });\n    \n    this.registerFunction('io_put', (key, value) => {\n      return this.context.io_put(key, value);\n    });\n  }\n  \n  /**\n   * Parse the source code and generate an AST\n   */\n  parse(sourceCode) {\n    try {\n      // Create lexer and parser\n      const lexer = new Lexer(sourceCode);\n      const parser = new Parser(lexer);\n      \n      // Parse the program to generate AST\n      this.ast = parser.parseProgram();\n      \n      // Collect any errors from the parser\n      this.errors = parser.errors;\n      \n      return {\n        success: this.errors.length === 0,\n        ast: this.ast,\n        errors: this.errors\n      };\n    } catch (error) {\n      this.errors.push({\n        message: `Unexpected error: ${error.message}`,\n        line: 0,\n        column: 0\n      });\n      \n      return {\n        success: false,\n        ast: null,\n        errors: this.errors\n      };\n    }\n  }\n  \n  /**\n   * Evaluate the AST and return the result\n   */\n  async evaluate(jsonData = {}, consoleOutput = []) {\n    this.errors = [];\n    \n    try {\n      // Create a new context that will directly modify the provided jsonData and consoleOutput\n      const prevContext = this.context;\n      this.context = new EvaluationContext(jsonData, consoleOutput);\n      \n      // Copy registered functions from previous context if it exists\n      if (prevContext && prevContext.functions) {\n        // Deep copy functions to ensure they're preserved\n        this.context.functions = { ...prevContext.functions };\n        \n        // Copy async functions\n        if (prevContext.asyncFunctions) {\n          this.context.asyncFunctions = new Set([...prevContext.asyncFunctions]);\n        }\n      } else {\n        // Re-register built-in functions if we don't have a previous context\n        this.registerBuiltInFunctions();\n      }\n      \n      // Check if we have a valid AST\n      if (!this.ast) {\n        this.errors.push({\n          message: 'No AST to evaluate. Parse code first.',\n          line: 0,\n          column: 0\n        });\n        \n        return {\n          success: false,\n          result: null,\n          jsonData,\n          consoleOutput,\n          errors: this.errors\n        };\n      }\n      \n      // Evaluate the program - the consoleOutput and jsonData will be modified directly\n      const result = await evaluate(this.ast, this.context);\n      \n      return {\n        success: true,\n        result,\n        jsonData,\n        consoleOutput,\n        errors: []\n      };\n    } catch (error) {\n      // Handle runtime errors\n      if (error instanceof RuntimeError) {\n        this.errors.push({\n          message: error.message,\n          line: error.line,\n          column: error.column\n        });\n      } else {\n        // Handle unexpected errors\n        this.errors.push({\n          message: `Unexpected error: ${error.message}`,\n          line: 0,\n          column: 0\n        });\n      }\n      \n      return {\n        success: false,\n        result: null,\n        jsonData,\n        consoleOutput,\n        errors: this.errors\n      };\n    }\n  }\n  \n  /**\n   * Register a custom library function\n   * @param {string} name - The name of the function\n   * @param {Function} implementation - The function implementation\n   * @param {boolean} isAsync - Whether the function is asynchronous (defaults to false)\n   * @returns {Function} The wrapped function\n   */\n  registerFunction(name, implementation, isAsync = false) {\n    if (!this.context) {\n      this.context = new EvaluationContext();\n    }\n    \n    return this.context.registerFunction(name, implementation, isAsync);\n  }\n  \n  /**\n   * Get the current evaluation context\n   */\n  getContext() {\n    return this.context;\n  }\n  \n  /**\n   * Return a JSON representation of the AST for visualization\n   */\n  getAstJson() {\n    if (!this.ast) {\n      return null;\n    }\n    \n    return this.ast.toJSON();\n  }\n  \n  /**\n   * Format errors into a readable string\n   */\n  formatErrors() {\n    if (this.errors.length === 0) {\n      return \"No errors\";\n    }\n    \n    return this.errors.map(error => {\n      return `[${error.line}:${error.column}] ${error.message}`;\n    }).join('\\n');\n  }\n}\n\n/**\n * Evaluate an AST in a given context\n * @param {Object} ast - The abstract syntax tree\n * @param {EvaluationContext} context - The evaluation context\n * @returns {*} The result of evaluation\n */\nexport async function evaluate(ast, context) {\n  // If the AST is an instance of a class rather than a plain object,\n  // and it has an evaluate method, use that directly\n  if (ast && typeof ast === 'object' && typeof ast.evaluate === 'function') {\n    return await ast.evaluate(context);\n  }\n\n  // Handle nodes defined as plain objects with type property\n  if (!ast || !ast.type) {\n    // Special case for Program node where type might not be directly defined\n    if (ast && (ast.statements || ast.body)) {\n      let result = null;\n      const statements = ast.statements || ast.body;\n      for (const statement of statements) {\n        result = await evaluate(statement, context);\n      }\n      return result;\n    }\n    throw new Error('Invalid AST node');\n  }\n\n  switch (ast.type) {\n    case 'Program': {\n      let result = null;\n      const statements = ast.statements || ast.body || [];\n      for (const statement of statements) {\n        result = await evaluate(statement, context);\n      }\n      return result;\n    }\n\n    case 'NumericLiteral':\n    case 'NumberLiteral':\n      return ast.value;\n\n    case 'StringLiteral':\n      return ast.value;\n      \n    case 'Identifier': {\n      // Important: Handle identifiers which may be variables or functions\n      const name = ast.name;\n      return context.lookupVariable(name);\n    }\n    \n    case 'BinaryExpression':\n    case 'InfixExpression': {\n      const left = await evaluate(ast.left, context);\n      const right = await evaluate(ast.right, context);\n\n      switch (ast.operator) {\n        case '+': return left + right;\n        case '-': return left - right;\n        case '*': return left * right;\n        case '/': return left / right;\n        case '%': return left % right;\n        case '<': return left < right;\n        case '>': return left > right;\n        case '<=': return left <= right;\n        case '>=': return left >= right;\n        case '==': return left === right;\n        case '!=': return left !== right;\n        case '&&': return left && right;\n        case '||': return left || right;\n        default: throw new Error(`Unknown binary operator: ${ast.operator}`);\n      }\n    }\n    \n    case 'UnaryExpression':\n    case 'PrefixExpression': {\n      const argument = await evaluate(ast.argument || ast.right, context);\n      switch (ast.operator) {\n        case '-': return -argument;\n        case '!': return !argument;\n        default: throw new Error(`Unknown unary operator: ${ast.operator}`);\n      }\n    }\n    \n    case 'VariableDeclaration': {\n      const initializer = ast.initializer || ast.init;\n      const varValue = initializer ? await evaluate(initializer, context) : undefined;\n      return context.assignVariable(ast.name || (ast.id && ast.id.name), varValue);\n    }\n\n    case 'AssignmentExpression':\n    case 'AssignmentStatement': {\n      let leftName;\n      if (ast.name) {\n        leftName = ast.name;\n      } else if (ast.left && ast.left.type === 'Identifier') {\n        leftName = ast.left.name;\n      } else {\n        throw new Error('Left side of assignment must be an identifier');\n      }\n      const assignValue = await evaluate(ast.right || ast.value, context);\n      return context.assignVariable(leftName, assignValue);\n    }\n\n    case 'BlockStatement': {\n      let blockResult = null;\n      const blockStatements = ast.statements || ast.body || [];\n      for (const statement of blockStatements) {\n        blockResult = await evaluate(statement, context);\n      }\n      return blockResult;\n    }\n\n    case 'IfStatement': {\n      const test = await evaluate(ast.test || ast.condition, context);\n      if (test) {\n        return await evaluate(ast.consequent || ast.consequence, context);\n      } else if (ast.alternate || ast.alternative) {\n        return await evaluate(ast.alternate || ast.alternative, context);\n      }\n      return null;\n    }\n\n    case 'WhileStatement': {\n      let whileResult = null;\n      const whileCondition = ast.test || ast.condition;\n      const whileBody = ast.body;\n      \n      while (await evaluate(whileCondition, context)) {\n        whileResult = await evaluate(whileBody, context);\n      }\n      return whileResult;\n    }\n\n    case 'CallExpression': {\n      // Extract the function name and handle different node structures\n      let functionName = null;\n      if (ast.callee) {\n        if (typeof ast.callee === 'string') {\n          functionName = ast.callee;\n        } else if (ast.callee.type === 'Identifier') {\n          functionName = ast.callee.name;\n        }\n      }\n      \n      if (functionName) {\n        // First check for library functions directly\n        const libraryFunc = context.lookupFunction(functionName);\n        \n        if (libraryFunc) {\n          // Evaluate all arguments\n          const args = [];\n          for (const arg of (ast.arguments || [])) {\n            args.push(await evaluate(arg, context));\n          }\n          \n          // Check if this is an async function\n          if (context.isAsyncFunction && context.isAsyncFunction(functionName)) {\n            return await libraryFunc(...args);\n          } else {\n            return libraryFunc(...args);\n          }\n        }\n        \n        // Then check for special IO functions (for backward compatibility)\n        if (functionName === 'io_get' && ast.arguments && ast.arguments.length === 1) {\n          const key = await evaluate(ast.arguments[0], context);\n          return context.io_get(key);\n        }\n        \n        if (functionName === 'io_put' && ast.arguments && ast.arguments.length === 2) {\n          const key = await evaluate(ast.arguments[0], context);\n          const value = await evaluate(ast.arguments[1], context);\n          return context.io_put(key, value);\n        }\n        \n        if (functionName === 'console_put' && ast.arguments && ast.arguments.length >= 1) {\n          const value = await evaluate(ast.arguments[0], context);\n          return context.console_put(value);\n        }\n        \n        // Check for user-defined functions\n        const func = context.lookupVariable(functionName);\n        if (typeof func === 'object' && func !== null && 'params' in func && 'body' in func) {\n          // Evaluate all arguments\n          const funcArgs = [];\n          for (const arg of (ast.arguments || [])) {\n            funcArgs.push(await evaluate(arg, context));\n          }\n          \n          // Create a new context with function parameters\n          const callContext = context.createChildContext();\n          \n          // Bind arguments to parameters\n          for (let i = 0; i < func.params.length; i++) {\n            callContext.assignVariable(func.params[i], funcArgs[i] || null);\n          }\n          \n          // Copy registered functions to new context\n          for (const key in context.functions) {\n            callContext.registerFunction(\n              key, \n              context.functions[key], \n              context.asyncFunctions && context.asyncFunctions.has(key)\n            );\n          }\n          \n          // Evaluate the function body with the new context\n          const result = await evaluate(func.body, callContext);\n          \n          // Return the result - it could be a ReturnValue which needs unwrapping\n          if (result && typeof result === 'object' && result.type === 'ReturnValue') {\n            return result.value;\n          }\n          \n          return result;\n        }\n      }\n      \n      // If we get here, we're calling a non-function\n      throw new Error(`Cannot call non-function: ${functionName || 'unknown'}`);\n    }\n\n    case 'ReturnStatement':\n      return ast.argument ? await evaluate(ast.argument || ast.value, context) : null;\n\n    case 'ArrayExpression': {\n      const elements = [];\n      for (const element of (ast.elements || [])) {\n        elements.push(await evaluate(element, context));\n      }\n      return elements;\n    }\n\n    case 'ObjectExpression': {\n      const obj = {};\n      for (const property of (ast.properties || [])) {\n        const key = property.key.type === 'Identifier' \n          ? property.key.name \n          : await evaluate(property.key, context);\n        obj[key] = await evaluate(property.value, context);\n      }\n      return obj;\n    }\n\n    case 'MemberExpression': {\n      const object = await evaluate(ast.object, context);\n      const property = ast.computed \n        ? await evaluate(ast.property, context)\n        : ast.property.name;\n      \n      if (object === null || object === undefined) {\n        throw new Error('Cannot access property of null or undefined');\n      }\n      \n      return object[property];\n    }\n\n    case 'ExpressionStatement':\n      return await evaluate(ast.expression, context);\n\n    default:\n      throw new Error(`Unknown AST node type: ${ast.type}`);\n  }\n} ","import { useState } from 'react';\nimport SourceEditor from './SourceEditor';\nimport ConsoleOutput from './ConsoleOutput';\nimport JsonEditor from './JsonEditor';\nimport { Interpreter } from '../../interpreter';\n\n// Default values for the editors\nconst DEFAULT_SOURCE = `// Sample program\ndef foo(x) {\n    if (x > 0) {\n        let y = x;\n        let i = 0;\n        while (i < 2) {\n            y = y * 2;\n            i = i + 1;\n        }\n        return y;\n    }\n    else {\n        return x * -2;\n    }\n}\n\nlet a = io_get('score'); // library function (access to json)\nlet msg = \"old:\";\nconsole_put(msg); // library function (access to log area)\nconsole_put(a);\n\nlet b = foo(a);\n\nio_put('score', b); \nconsole_put(\"new:\");\nconsole_put(b);`;\n\nconst SIMPLE_EXAMPLE = `// Simple \"Hello, World!\" example\nlet message = \"Hello, World!\";\nconsole_put(message);`;\n\nconst SIMPLE_JSON_DATA = `{\n  \"user\": \"Learner\"\n}`;\n\nconst ADVANCED_EXAMPLE = `// Advanced example showcasing language features\ndef calculate(x, y) {\n  // Function with parameters and return value\n  let result = 0;\n  \n  // If-else control structure\n  if (x > y) {\n    result = x * 2 - y;\n  } else if (x < y) {\n    result = y * 2 - x;\n  } else {\n    result = x + y;\n  }\n  \n  // While loop\n  let i = 0;\n  while (i < 3) {\n    result = result + i;\n    i = i + 1;\n  }\n  \n  return result;\n}\n\n// Variable declaration and assignment\nlet userName = io_get(\"user\");\nlet numbers = [10, 20, 30, 40, 50];\n\n// Retrieving data from JSON\nlet isActive = io_get(\"active\");\nlet userScore = io_get(\"score\");\n\n// Array access with indexing\nlet selectedNumber = numbers[2];\n\n// Function call\nlet calculatedValue = calculate(selectedNumber, 25);\n\n// String concatenation\nconsole_put(\"Hello, \" + userName + \"!\");\nconsole_put(\"Selected number: \" + selectedNumber);\nconsole_put(\"Calculation result: \" + calculatedValue);\n\n// Boolean logic\nif (isActive && userScore > 30) {\n  console_put(\"User has high score and is active!\");\n} else if (!isActive || userScore < 10) {\n  console_put(\"User needs to improve activity or score.\");\n} else {\n  console_put(\"User is doing fine.\");\n}\n\n// Store results back to JSON\nio_put(\"result\", calculatedValue);\nio_put(\"selectedNumber\", selectedNumber);\n\n// Return the final result\ncalculatedValue;`;\n\nconst DEFAULT_JSON_DATA = `{\n  \"user\": \"Developer\",\n  \"active\": true,\n  \"score\": 45,\n  \"theme\": \"dark\",\n  \"notifications\": true\n}`;\n\nfunction IDE() {\n  const [source, setSource] = useState(DEFAULT_SOURCE);\n  const [jsonData, setJsonData] = useState(DEFAULT_JSON_DATA);\n  const [output, setOutput] = useState('');\n  \n  const handleRun = async () => {\n    try {\n      // Start with a fresh console output\n      setOutput('$ Parsing program...\\n');\n      \n      // Create a fresh interpreter instance to avoid any caching issues\n      const interpreter = new Interpreter();\n      \n      // Parse the source code\n      const parseResult = interpreter.parse(source);\n      \n      if (parseResult.success) {\n        setOutput('$ Parsing program...\\n$ Parsing successful!\\n\\n');\n        \n        try {\n          // Parse the JSON data\n          const parsedJsonData = JSON.parse(jsonData);\n          \n          // Create an array to capture console output\n          const consoleOutput = [];\n          \n          // Execute the program\n          setOutput('$ Executing program...\\n');\n          // await the evaluation since it's now async\n          const evalResult = await interpreter.evaluate(parsedJsonData, consoleOutput);\n          \n          if (evalResult.success) {\n            // Format the updated JSON\n            const updatedJson = JSON.stringify(evalResult.jsonData, null, 2);\n            \n            // Update the JSON editor with the new values\n            setJsonData(updatedJson);\n            \n            // Format and display console output\n            const formattedOutput = consoleOutput.map(line => `> ${line}`).join('\\n');\n            \n            setOutput('$ Program output:\\n' +\n              formattedOutput + '\\n\\n' +\n              '$ Result: ' + (evalResult.result !== undefined ? JSON.stringify(evalResult.result) : 'undefined')\n            );\n          } else {\n            // Show execution errors\n            const errorMessages = evalResult.errors.map(err => \n              `[${err.line}:${err.column}] ${err.message}`\n            ).join('\\n');\n            \n            setOutput(prevOutput => \n              prevOutput + \n              '$ Execution failed!\\n\\n' + \n              errorMessages\n            );\n          }\n        } catch (error) {\n          // Differentiate between JSON parsing errors and other errors\n          if (error instanceof SyntaxError && error.message.includes('JSON')) {\n            setOutput(prevOutput => \n              prevOutput + \n              `$ JSON parsing error: ${error.message}\\n` +\n              '$ Please check your JSON data and try again.'\n            );\n          } else {\n            setOutput(prevOutput => \n              prevOutput + \n              `$ Unexpected error: ${error.message}\\n` +\n              '$ Please check your code and try again.'\n            );\n          }\n        }\n      } else {\n        // Show parsing errors\n        const errorMessages = parseResult.errors.map(err => \n          `[${err.line}:${err.column}] ${err.message}`\n        ).join('\\n');\n        \n        setOutput('$ Parsing program...\\n$ Parsing failed!\\n\\n' + errorMessages);\n      }\n    } catch (error) {\n      setOutput(`$ Error: ${error.message}`);\n    }\n  };\n  \n  const loadSimpleExample = () => {\n    setSource(SIMPLE_EXAMPLE);\n    setJsonData(SIMPLE_JSON_DATA);\n    setOutput('$ Loaded simple example. Click \"Run\" to execute it.');\n  };\n  \n  const loadAdvancedExample = () => {\n    setSource(ADVANCED_EXAMPLE);\n    setJsonData(DEFAULT_JSON_DATA);\n    setOutput('$ Loaded advanced example. Click \"Run\" to execute it.');\n  };\n  \n  return (\n    <div className=\"flex flex-col h-[calc(100vh-200px)] gap-4\">\n      <div className=\"flex flex-grow gap-4 min-h-0\">\n        {/* Left side: Source Editor (takes 2/3 of the width) */}\n        <div className=\"w-2/3 min-h-0 flex flex-col\">\n          <div className=\"flex mb-2 gap-2\">\n            <button \n              onClick={loadSimpleExample}\n              className=\"px-2 py-1 text-sm bg-blue-100 text-blue-800 rounded hover:bg-blue-200\"\n            >\n              Load Simple Example\n            </button>\n            <button \n              onClick={loadAdvancedExample}\n              className=\"px-2 py-1 text-sm bg-blue-100 text-blue-800 rounded hover:bg-blue-200\"\n            >\n              Load Advanced Example\n            </button>\n          </div>\n          <SourceEditor \n            source={source} \n            onSourceChange={setSource} \n            onRun={handleRun} \n          />\n        </div>\n        \n        {/* Right side: JSON Editor (takes 1/3 of the width) */}\n        <div className=\"w-1/3 min-h-0\">\n          <JsonEditor\n            jsonData={jsonData}\n            onJsonChange={setJsonData}\n          />\n        </div>\n      </div>\n      \n      {/* Bottom: Console Output (fixed height) */}\n      <div className=\"h-1/3 min-h-0\">\n        <ConsoleOutput output={output} />\n      </div>\n    </div>\n  );\n}\n\nexport default IDE; ","import IDE from '../components/ide/IDE';\n\nfunction Home() {\n  return (\n    <div className=\"py-6\">\n      <IDE />\n    </div>\n  );\n}\n\nexport default Home; ","import { Routes, Route } from 'react-router-dom';\nimport Layout from './components/Layout';\nimport Home from './pages/Home';\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route index element={<Home />} />\n      </Route>\n    </Routes>\n  );\n}\n\nexport default App;\n","import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { BrowserRouter } from 'react-router-dom'\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <BrowserRouter basename={import.meta.env.BASE_URL}>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>,\n)\n"],"names":["relList","document","createElement","supports","link","querySelectorAll","processPreload","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","ep","fetchOpts","script","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","fetch","href","m","require$$0","Header","className","children","Footer","year","Date","getFullYear","Layout","_jsx","Outlet","SourceEditor","source","onSourceChange","onRun","_jsxs","onClick","xmlns","viewBox","fill","fillRule","d","clipRule","placeholder","value","onChange","e","target","spellCheck","ConsoleOutput","output","role","JsonEditor","jsonData","onJsonChange","client","createRoot","hydrateRoot","TokenType","Keywords","def","let","if","else","while","return","true","false","null","Token","constructor","literal","line","column","this","toString","Lexer","input","position","readPosition","ch","readChar","length","peekChar","nextToken","token","skipWhitespace","skipComments","startColumn","stringLiteral","readString","isLetter","identifier","readIdentifier","isDigit","number","readNumber","slice","quote","commentEnd","tokenize","tokens","push","ReturnValue","LibraryFunction","name","jsFunction","isAsync","implementation","RuntimeError","Error","message","super","Environment","parent","values","Map","libraryFunctions","extend","define","set","get","has","assign","registerLibraryFunction","libraryFunction","EvaluationContext","consoleOutput","variables","functions","asyncFunctions","Set","environment","getEnvironment","stringify","JSON","String","lookupVariable","assignVariable","lookupFunction","isAsyncFunction","registerFunction","func","wrappedFunc","args","Array","isArray","some","item","add","io_get","key","io_put","actualKey","actualValue","console_put","createChildContext","childContext","Object","keys","forEach","Node","toJSON","evaluate","context","Program","statements","map","stmt","result","statement","BlockStatement","ExpressionStatement","expression","VariableDeclaration","initializer","AssignmentStatement","FunctionDeclaration","parameters","body","async","functionEnv","i","param","arg","previousEnv","ReturnStatement","IfStatement","condition","consequence","alternative","isTruthy","WhileStatement","Identifier","error","envError","NumberLiteral","StringLiteral","BooleanLiteral","NullLiteral","PrefixExpression","operator","right","InfixExpression","left","CallExpression","callee","arguments","funcName","MemberExpression","object","property","computed","ArrayLiteral","elements","element","PRECEDENCE","PRECEDENCES","TokenType_OR","TokenType_AND","TokenType_EQ","TokenType_NOT_EQ","TokenType_LT","TokenType_GT","TokenType_LT_EQ","TokenType_GT_EQ","TokenType_PLUS","TokenType_MINUS","TokenType_ASTERISK","TokenType_SLASH","TokenType_PERCENT","TokenType_LPAREN","TokenType_DOT","TokenType_LBRACKET","Parser","lexer","currentPosition","errors","prefixParseFns","infixParseFns","registerPrefix","parseIdentifier","bind","parseNumberLiteral","parseStringLiteral","parseBooleanLiteral","parseNullLiteral","parseGroupedExpression","parsePrefixExpression","parseArrayLiteral","registerInfix","parseInfixExpression","parseCallExpression","parseMemberExpression","parseIndexExpression","parseProgram","program","AST.Program","currentTokenIs","parseStatement","tokenType","fn","currentToken","peekToken","peekTokenIs","expectPeek","peekError","msg","_a","_b","_c","peekPrecedence","currentPrecedence","parseFunctionDeclaration","parseVariableDeclaration","parseIfStatement","parseWhileStatement","parseReturnStatement","parseBlockStatement","parseAssignmentStatement","parseExpressionStatement","block","AST.BlockStatement","functionDecl","AST.FunctionDeclaration","parseFunctionParameters","declaration","AST.VariableDeclaration","parseExpression","assignment","AST.AssignmentStatement","parseAssignmentExpression","ifStmt","AST.IfStatement","whileStmt","AST.WhileStatement","returnStmt","AST.ReturnStatement","AST.ExpressionStatement","precedence","prefixFn","leftExp","infixFn","AST.Identifier","AST.NumberLiteral","includes","parseFloat","parseInt","string","AST.StringLiteral","boolean","AST.BooleanLiteral","nullLiteral","AST.NullLiteral","exp","AST.PrefixExpression","AST.InfixExpression","AST.CallExpression","parseCallArguments","parseExpressionList","memberExp","AST.MemberExpression","indexExp","array","AST.ArrayLiteral","endToken","expressions","Interpreter","ast","registerBuiltInFunctions","parse","sourceCode","parser","success","prevContext","getContext","getAstJson","formatErrors","join","argument","init","varValue","id","leftName","assignValue","blockResult","blockStatements","test","consequent","alternate","whileResult","whileCondition","whileBody","functionName","libraryFunc","funcArgs","callContext","params","obj","properties","DEFAULT_SOURCE","SIMPLE_EXAMPLE","SIMPLE_JSON_DATA","ADVANCED_EXAMPLE","DEFAULT_JSON_DATA","IDE","setSource","useState","setJsonData","setOutput","loadSimpleExample","loadAdvancedExample","interpreter","parseResult","parsedJsonData","evalResult","updatedJson","formattedOutput","undefined","errorMessages","err","prevOutput","SyntaxError","Home","App","Routes","Route","path","index","ReactDOM","getElementById","render","React","StrictMode","BrowserRouter","basename","import"],"mappings":"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"}