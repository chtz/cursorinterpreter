{"version":3,"file":"index.93844962.js","sources":["../../vite/modulepreload-polyfill","../../node_modules/react-dom/client.js","../../src/components/Header.jsx","../../src/components/Footer.jsx","../../src/components/Layout.jsx","../../src/components/ide/SourceEditor.jsx","../../src/components/ide/ConsoleOutput.jsx","../../src/components/ide/JsonEditor.jsx","../../src/interpreter/tokens.js","../../src/interpreter/lexer.js","../../src/interpreter/runtime.js","../../src/interpreter/ast.js","../../src/interpreter/parser.js","../../src/interpreter/index.js","../../src/components/ide/IDE.jsx","../../src/pages/Home.jsx","../../src/App.jsx","../../src/main.jsx"],"sourcesContent":["__VITE_IS_MODERN__&&(function polyfill() {\n    const relList = document.createElement('link').relList;\n    if (relList && relList.supports && relList.supports('modulepreload')) {\n        return;\n    }\n    for (const link of document.querySelectorAll('link[rel=\"modulepreload\"]')) {\n        processPreload(link);\n    }\n    new MutationObserver((mutations) => {\n        for (const mutation of mutations) {\n            if (mutation.type !== 'childList') {\n                continue;\n            }\n            for (const node of mutation.addedNodes) {\n                if (node.tagName === 'LINK' && node.rel === 'modulepreload')\n                    processPreload(node);\n            }\n        }\n    }).observe(document, { childList: true, subtree: true });\n    function getFetchOpts(script) {\n        const fetchOpts = {};\n        if (script.integrity)\n            fetchOpts.integrity = script.integrity;\n        if (script.referrerpolicy)\n            fetchOpts.referrerPolicy = script.referrerpolicy;\n        if (script.crossorigin === 'use-credentials')\n            fetchOpts.credentials = 'include';\n        else if (script.crossorigin === 'anonymous')\n            fetchOpts.credentials = 'omit';\n        else\n            fetchOpts.credentials = 'same-origin';\n        return fetchOpts;\n    }\n    function processPreload(link) {\n        if (link.ep)\n            // ep marker = processed\n            return;\n        link.ep = true;\n        // prepopulate the load record\n        const fetchOpts = getFetchOpts(link);\n        fetch(link.href, fetchOpts);\n    }\n}());","'use strict';\n\nvar m = require('react-dom');\nif (process.env.NODE_ENV === 'production') {\n  exports.createRoot = m.createRoot;\n  exports.hydrateRoot = m.hydrateRoot;\n} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n","function Header() {\n  return (\n    <header className=\"bg-blue-600 text-white p-4 shadow-md\">\n      <div className=\"container mx-auto\">\n        <h1 className=\"text-2xl font-bold\">The Interpreter</h1>\n      </div>\n    </header>\n  );\n}\n\nexport default Header; ","function Footer() {\n  const year = new Date().getFullYear();\n  \n  return (\n    <footer className=\"bg-gray-800 text-white p-4 mt-auto\">\n      <div className=\"container mx-auto text-center\">\n        <p>&copy; {year} cht_z. All rights reserved.</p>\n      </div>\n    </footer>\n  );\n}\n\nexport default Footer; ","import { Outlet } from 'react-router-dom';\nimport Header from './Header';\nimport Footer from './Footer';\n\nfunction Layout() {\n  return (\n    <div className=\"flex flex-col min-h-screen\">\n      <Header />\n      <main className=\"flex-grow container mx-auto p-4\">\n        <Outlet />\n      </main>\n      <Footer />\n    </div>\n  );\n}\n\nexport default Layout; ","function SourceEditor({ source, onSourceChange, onRun }) {\n  return (\n    <div className=\"border border-gray-300 rounded-md h-full flex flex-col\">\n      <div className=\"flex justify-between items-center p-2 bg-gray-100 border-gray-300\">\n        <h3 className=\"font-medium\">Source Code</h3>\n        <button \n          className=\"bg-green-500 text-white px-3 py-1 rounded-md hover:bg-green-600 flex items-center\"\n          onClick={onRun}\n          aria-label=\"Run code\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" className=\"h-4 w-4 mr-1\" viewBox=\"0 0 20 20\" fill=\"currentColor\" aria-hidden=\"true\">\n            <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z\" clipRule=\"evenodd\" />\n          </svg>\n          Run\n        </button>\n      </div>\n      <textarea \n        className=\"flex-grow p-4 font-mono text-sm resize-none focus:outline-none\"\n        placeholder=\"// Write your code here...\"\n        value={source}\n        onChange={(e) => onSourceChange(e.target.value)}\n        aria-label=\"Source code editor\"\n        spellCheck=\"false\"\n      />\n    </div>\n  );\n}\n\nexport default SourceEditor; ","function ConsoleOutput({ output }) {\n  return (\n    <div className=\"border border-gray-300 rounded-md h-full flex flex-col\">\n      <div className=\"bg-gray-100 p-2 border-b border-gray-300\">\n        <h3 className=\"font-medium\">Console Output</h3>\n      </div>\n      <div \n        className=\"flex-grow bg-gray-900 p-4 font-mono text-sm text-green-400 overflow-y-auto\"\n        role=\"log\"\n        aria-live=\"polite\"\n        aria-label=\"Console output\"\n      >\n        <div className=\"whitespace-pre-wrap\">\n          {output}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default ConsoleOutput; ","function JsonEditor({ jsonData, onJsonChange }) {\n  return (\n    <div className=\"border border-gray-300 rounded-md h-full flex flex-col\">\n      <div className=\"bg-gray-100 p-2 border-b border-gray-300\">\n        <h3 className=\"font-medium\">JSON Data</h3>\n      </div>\n      <textarea \n        className=\"flex-grow p-4 font-mono text-sm resize-none focus:outline-none bg-gray-50\"\n        placeholder=\"{}\"\n        value={jsonData}\n        onChange={(e) => onJsonChange(e.target.value)}\n        aria-label=\"JSON data editor\"\n        spellCheck=\"false\"\n      />\n    </div>\n  );\n}\n\nexport default JsonEditor; ","/**\n * Token types for the Cursor Interpreter language\n */\nexport const TokenType = {\n  // Special tokens\n  EOF: 'EOF',\n  ILLEGAL: 'ILLEGAL',\n  \n  // Identifiers and literals\n  IDENTIFIER: 'IDENTIFIER',\n  NUMBER: 'NUMBER',\n  STRING: 'STRING',\n  \n  // Keywords\n  DEF: 'DEF',\n  LET: 'LET',\n  IF: 'IF',\n  ELSE: 'ELSE',\n  WHILE: 'WHILE',\n  RETURN: 'RETURN',\n  TRUE: 'TRUE',\n  FALSE: 'FALSE',\n  NULL: 'NULL',\n  \n  // Operators\n  PLUS: '+',\n  MINUS: '-',\n  ASTERISK: '*',\n  SLASH: '/',\n  PERCENT: '%',\n  \n  // Comparison operators\n  EQ: '==',\n  NOT_EQ: '!=',\n  LT: '<',\n  GT: '>',\n  LT_EQ: '<=',\n  GT_EQ: '>=',\n  \n  // Logical operators\n  AND: '&&',\n  OR: '||',\n  NOT: '!',\n  \n  // Assignment\n  ASSIGN: '=',\n  \n  // Delimiters\n  COMMA: ',',\n  SEMICOLON: ';',\n  LPAREN: '(',\n  RPAREN: ')',\n  LBRACE: '{',\n  RBRACE: '}',\n  \n  // Member access\n  DOT: '.',\n  \n  // Array access\n  LBRACKET: '[',\n  RBRACKET: ']',\n};\n\n/**\n * Keywords mapping for the language\n */\nexport const Keywords = {\n  'def': TokenType.DEF,\n  'let': TokenType.LET,\n  'if': TokenType.IF,\n  'else': TokenType.ELSE,\n  'while': TokenType.WHILE,\n  'return': TokenType.RETURN,\n  'true': TokenType.TRUE,\n  'false': TokenType.FALSE,\n  'null': TokenType.NULL,\n};\n\n/**\n * Token class to represent a lexical token\n */\nexport class Token {\n  constructor(type, literal, line, column) {\n    this.type = type;\n    this.literal = literal;\n    this.line = line;\n    this.column = column;\n  }\n  \n  toString() {\n    return `Token(${this.type}, '${this.literal}', ${this.line}:${this.column})`;\n  }\n} ","import { TokenType, Keywords, Token } from './tokens.js';\n\n/**\n * Lexer class to tokenize the input source code\n * Following the KISS principle: Simple, straightforward lexical analysis\n */\nexport class Lexer {\n  constructor(input) {\n    this.input = input;\n    this.position = 0;      // Current position in input (points to current character)\n    this.readPosition = 0;  // Next position in input (after current character)\n    this.ch = '';           // Current character under examination\n    this.line = 1;          // Current line number\n    this.column = 0;        // Current column number\n    \n    this.readChar(); // Initialize first character\n  }\n  \n  /**\n   * Advances to the next character in the input\n   */\n  readChar() {\n    if (this.readPosition >= this.input.length) {\n      this.ch = ''; // EOF\n    } else {\n      this.ch = this.input[this.readPosition];\n    }\n    \n    this.position = this.readPosition;\n    this.readPosition += 1;\n    this.column += 1;\n  }\n  \n  /**\n   * Peeks at the next character without advancing\n   */\n  peekChar() {\n    if (this.readPosition >= this.input.length) {\n      return ''; // EOF\n    } else {\n      return this.input[this.readPosition];\n    }\n  }\n  \n  /**\n   * Reads the next token from the input\n   */\n  nextToken() {\n    let token;\n    \n    this.skipWhitespace();\n    this.skipComments();\n    \n    switch (this.ch) {\n      case '=':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.ASSIGN, this.ch, this.line, this.column);\n        }\n        break;\n      case '+':\n        token = new Token(TokenType.PLUS, this.ch, this.line, this.column);\n        break;\n      case '-':\n        token = new Token(TokenType.MINUS, this.ch, this.line, this.column);\n        break;\n      case '*':\n        token = new Token(TokenType.ASTERISK, this.ch, this.line, this.column);\n        break;\n      case '#':\n        this.skipComments();\n        return this.nextToken();\n      case '/':\n        if (this.peekChar() === '/' || this.peekChar() === '*') {\n          this.skipComments();\n          return this.nextToken();\n        } else {\n          token = new Token(TokenType.SLASH, this.ch, this.line, this.column);\n        }\n        break;\n      case '%':\n        token = new Token(TokenType.PERCENT, this.ch, this.line, this.column);\n        break;\n      case '!':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.NOT_EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.NOT, this.ch, this.line, this.column);\n        }\n        break;\n      case '<':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.LT_EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.LT, this.ch, this.line, this.column);\n        }\n        break;\n      case '>':\n        if (this.peekChar() === '=') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.GT_EQ, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.GT, this.ch, this.line, this.column);\n        }\n        break;\n      case '&':\n        if (this.peekChar() === '&') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.AND, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.ILLEGAL, this.ch, this.line, this.column);\n        }\n        break;\n      case '|':\n        if (this.peekChar() === '|') {\n          const ch = this.ch;\n          this.readChar();\n          const literal = ch + this.ch;\n          token = new Token(TokenType.OR, literal, this.line, this.column - 1);\n        } else {\n          token = new Token(TokenType.ILLEGAL, this.ch, this.line, this.column);\n        }\n        break;\n      case ',':\n        token = new Token(TokenType.COMMA, this.ch, this.line, this.column);\n        break;\n      case ';':\n        token = new Token(TokenType.SEMICOLON, this.ch, this.line, this.column);\n        break;\n      case '.':\n        token = new Token(TokenType.DOT, this.ch, this.line, this.column);\n        break;\n      case '(':\n        token = new Token(TokenType.LPAREN, this.ch, this.line, this.column);\n        break;\n      case ')':\n        token = new Token(TokenType.RPAREN, this.ch, this.line, this.column);\n        break;\n      case '{':\n        token = new Token(TokenType.LBRACE, this.ch, this.line, this.column);\n        break;\n      case '}':\n        token = new Token(TokenType.RBRACE, this.ch, this.line, this.column);\n        break;\n      case '\"':\n      case \"'\":\n        const startColumn = this.column;\n        const stringLiteral = this.readString(this.ch);\n        token = new Token(TokenType.STRING, stringLiteral, this.line, startColumn);\n        break;\n      case '':\n        token = new Token(TokenType.EOF, '', this.line, this.column);\n        break;\n      case '[':\n        token = new Token(TokenType.LBRACKET, this.ch, this.line, this.column);\n        break;\n      case ']':\n        token = new Token(TokenType.RBRACKET, this.ch, this.line, this.column);\n        break;\n      default:\n        if (this.isLetter(this.ch)) {\n          const startColumn = this.column;\n          const identifier = this.readIdentifier();\n          const type = Keywords[identifier] || TokenType.IDENTIFIER;\n          token = new Token(type, identifier, this.line, startColumn);\n          return token;\n        } else if (this.isDigit(this.ch)) {\n          const startColumn = this.column;\n          const number = this.readNumber();\n          token = new Token(TokenType.NUMBER, number, this.line, startColumn);\n          return token;\n        } else {\n          token = new Token(TokenType.ILLEGAL, this.ch, this.line, this.column);\n        }\n    }\n    \n    this.readChar();\n    return token;\n  }\n  \n  /**\n   * Reads an identifier from the input\n   */\n  readIdentifier() {\n    const position = this.position;\n    while (this.isLetter(this.ch) || this.isDigit(this.ch)) {\n      this.readChar();\n    }\n    return this.input.slice(position, this.position);\n  }\n  \n  /**\n   * Reads a number from the input (integers and floats)\n   */\n  readNumber() {\n    const position = this.position;\n    \n    // Read integer part\n    while (this.isDigit(this.ch)) {\n      this.readChar();\n    }\n    \n    // Check for decimal point\n    if (this.ch === '.' && this.isDigit(this.peekChar())) {\n      this.readChar(); // consume the decimal point\n      \n      // Read decimal part\n      while (this.isDigit(this.ch)) {\n        this.readChar();\n      }\n    }\n    \n    return this.input.slice(position, this.position);\n  }\n  \n  /**\n   * Reads a string literal from the input\n   */\n  readString(quote) {\n    this.readChar(); // Skip the opening quote\n    const position = this.position;\n    \n    while (this.ch !== quote && this.ch !== '') {\n      // Handle escape sequences\n      if (this.ch === '\\\\' && (this.peekChar() === quote || this.peekChar() === '\\\\')) {\n        this.readChar(); // Skip the backslash\n      }\n      \n      // Handle newline in string\n      if (this.ch === '\\n') {\n        this.line++;\n        this.column = 0;\n      }\n      \n      this.readChar();\n    }\n    \n    const str = this.input.slice(position, this.position);\n    return str;\n  }\n  \n  /**\n   * Skips whitespace characters\n   */\n  skipWhitespace() {\n    while (this.ch === ' ' || this.ch === '\\t' || this.ch === '\\r' || this.ch === '\\n') {\n      if (this.ch === '\\n') {\n        this.line++;\n        this.column = 0;\n      }\n      this.readChar();\n    }\n  }\n  \n  /**\n   * Skips comments (both single-line and multi-line)\n   */\n  skipComments() {\n    if (this.ch === '#' || this.ch === '/' && this.peekChar() === '/') {\n      // Single-line comment\n      while (this.ch !== '\\n' && this.ch !== '') {\n        this.readChar();\n      }\n      this.skipWhitespace();\n    } else if (this.ch === '/' && this.peekChar() === '*') {\n      // Multi-line comment\n      this.readChar(); // Skip the first /\n      this.readChar(); // Skip the *\n      \n      let commentEnd = false;\n      while (!commentEnd && this.ch !== '') {\n        if (this.ch === '*' && this.peekChar() === '/') {\n          commentEnd = true;\n          this.readChar(); // Skip the *\n          this.readChar(); // Skip the /\n        } else {\n          if (this.ch === '\\n') {\n            this.line++;\n            this.column = 0;\n          }\n          this.readChar();\n        }\n      }\n      \n      this.skipWhitespace();\n    }\n  }\n  \n  /**\n   * Checks if a character is a letter (a-z, A-Z, _)\n   */\n  isLetter(ch) {\n    return ('a' <= ch && ch <= 'z') || ('A' <= ch && ch <= 'Z') || ch === '_';\n  }\n  \n  /**\n   * Checks if a character is a digit (0-9)\n   */\n  isDigit(ch) {\n    return '0' <= ch && ch <= '9';\n  }\n  \n  /**\n   * Tokenizes the entire input and returns an array of tokens\n   */\n  tokenize() {\n    const tokens = [];\n    let token = this.nextToken();\n    \n    while (token.type !== TokenType.EOF) {\n      tokens.push(token);\n      token = this.nextToken();\n    }\n    \n    tokens.push(token); // Add EOF token\n    return tokens;\n  }\n} ","/**\n * Runtime environment for the interpreter\n * Manages scope, variables, functions, and error handling\n */\n\n// Return value object used for function returns and control flow\nexport class ReturnValue {\n  constructor(value) {\n    this.value = value;\n  }\n}\n\n// Built-in library function type\nexport class LibraryFunction {\n  constructor(name, jsFunction, isAsync = false) {\n    this.name = name;\n    this.implementation = jsFunction;\n    this.isAsync = isAsync;\n  }\n}\n\n// Runtime error with position information\nexport class RuntimeError extends Error {\n  constructor(message, line, column) {\n    super(message);\n    this.line = line || 0;\n    this.column = column || 0;\n    this.name = 'RuntimeError';\n  }\n}\n\n// Environment to store variables and functions in the current scope\nexport class Environment {\n  constructor(parent = null) {\n    this.parent = parent;\n    this.values = new Map();\n    this.libraryFunctions = new Map();\n  }\n\n  // Create a new nested scope\n  extend() {\n    return new Environment(this);\n  }\n\n  // Define a variable in the current scope\n  define(name, value) {\n    this.values.set(name, value);\n    return value;\n  }\n\n  // Get a variable from the current or parent scopes\n  get(name, position) {\n    if (this.values.has(name)) {\n      return this.values.get(name);\n    }\n\n    // Check if it's a library function\n    if (this.libraryFunctions.has(name)) {\n      return this.libraryFunctions.get(name);\n    }\n\n    // Look in parent scope\n    if (this.parent) {\n      return this.parent.get(name, position);\n    }\n\n    throw new RuntimeError(`Undefined variable '${name}'`, position?.line, position?.column);\n  }\n\n  // Set a variable in the current or parent scopes\n  assign(name, value, position) {\n    if (this.values.has(name)) {\n      this.values.set(name, value);\n      return value;\n    }\n\n    // Try to assign in parent scope\n    if (this.parent) {\n      return this.parent.assign(name, value, position);\n    }\n\n    throw new RuntimeError(`Cannot assign to undefined variable '${name}'`, position?.line, position?.column);\n  }\n\n  // Register a library function\n  registerLibraryFunction(name, implementation, isAsync = false) {\n    const libraryFunction = new LibraryFunction(name, implementation, isAsync);\n    this.libraryFunctions.set(name, libraryFunction);\n    return libraryFunction;\n  }\n}\n\n/**\n * Evaluation context for the interpreter\n * \n * This class manages the execution environment for the interpreter,\n * including variables, functions, JSON data, and console output.\n */\nexport class EvaluationContext {\n  /**\n   * Create a new evaluation context with the given data\n   * \n   * @param {Object} jsonData - The initial JSON data object\n   * @param {Array} consoleOutput - The array to collect console output\n   * @param {EvaluationContext} parentContext - The parent context for closures\n   */\n  constructor(jsonData = {}, consoleOutput = [], parentContext = null) {\n    // Execution context variables (user-defined)\n    this.variables = {};\n    // Parent context for closure support\n    this.parentContext = parentContext;\n    // JSON data for I/O operations (external data)\n    this.jsonData = jsonData;\n    // Console output buffer for logging\n    this.consoleOutput = consoleOutput;\n    // Library functions (built-in and user-registered)\n    this.functions = {};\n    // Track which functions are async\n    this.asyncFunctions = new Set();\n    // Create environment for scoped variables\n    this.environment = new Environment();\n  }\n\n  /**\n   * Get the current environment\n   * @returns {Environment} The current environment\n   */\n  getEnvironment() {\n    return this.environment;\n  }\n\n  /**\n   * Convert a value to a string for display\n   * @param {*} value - The value to stringify\n   * @returns {string} The string representation\n   */\n  stringify(value) {\n    if (value === null) return 'null';\n    if (value === undefined) return 'undefined';\n    if (typeof value === 'object') return JSON.stringify(value);\n    return String(value);\n  }\n\n  /**\n   * Lookup a variable value from the context\n   * @param {string} name - The variable name\n   * @returns {*} The variable value\n   * @throws {Error} If the variable is not defined\n   */\n  lookupVariable(name) {\n    // First check variables in current context\n    if (name in this.variables) {\n      return this.variables[name];\n    }\n    \n    // Then check functions (for function calls)\n    if (name in this.functions) {\n      return this.functions[name];\n    }\n    \n    // Check parent context if available (closure support)\n    if (this.parentContext) {\n      try {\n        return this.parentContext.lookupVariable(name);\n      } catch (e) {\n        // Continue to environment check if parent doesn't have it\n      }\n    }\n    \n    // Finally check environment\n    try {\n      if (this.environment) {\n        return this.environment.get(name);\n      }\n    } catch (e) {\n      // Don't throw here, we'll throw our own error below\n    }\n    \n    // If we get here, the variable wasn't found\n    throw new RuntimeError(\n      `Undefined variable '${name}'`,\n      0,\n      0\n    );\n  }\n\n  /**\n   * Assign a value to a variable in the context\n   * @param {string} name - The variable name\n   * @param {*} value - The value to assign\n   * @returns {*} The assigned value\n   */\n  assignVariable(name, value) {\n    // Check if the variable exists in a parent context and update there\n    if (!(name in this.variables) && this.parentContext) {\n      try {\n        // Try to look up the variable in parent contexts\n        this.parentContext.lookupVariable(name);\n        // If we get here, the variable exists in the parent context, so update it there\n        return this.parentContext.assignVariable(name, value);\n      } catch (e) {\n        // Variable doesn't exist in parent contexts, assign it in current context\n      }\n    }\n    \n    // Assign/update in the current context\n    this.variables[name] = value;\n    return value;\n  }\n\n  /**\n   * Lookup a function from the context\n   * @param {string} name - The function name\n   * @returns {Function|null} The function or null if not found\n   */\n  lookupFunction(name) {\n    if (name in this.functions) {\n      return this.functions[name];\n    }\n    return null;\n  }\n\n  /**\n   * Check if a function is async\n   * @param {string} name - The function name\n   * @returns {boolean} True if the function is async\n   */\n  isAsyncFunction(name) {\n    return this.asyncFunctions.has(name);\n  }\n\n  /**\n   * Register a function in the context\n   * @param {string} name - The function name\n   * @param {Function} func - The function implementation\n   * @param {boolean} isAsync - Whether the function is asynchronous\n   * @returns {Function} The wrapped function\n   */\n  registerFunction(name, func, isAsync = false) {\n    // Wrap the function to ensure proper argument handling\n    const wrappedFunc = (...args) => {\n      // Special handling for array arguments\n      if (args.length === 1 && Array.isArray(args[0])) {\n        // If there's only one argument and it's an array, it could be:\n        // 1. An actual array parameter from the script\n        // 2. The arguments array from a CallExpression\n        \n        // Check if this array contains arrays or objects that appear to be AST nodes\n        const isArgArray = args[0].some(item => \n          (typeof item === 'object' && item !== null && \n           (item.type || Array.isArray(item)))\n        );\n        \n        if (isArgArray) {\n          // This is likely an arguments array, so pass it to the function\n          return func(...args[0]);\n        } else {\n          // This is likely an actual array parameter, pass it directly\n          return func(args[0]);\n        }\n      }\n      \n      // Otherwise pass all arguments directly\n      return func(...args);\n    };\n    \n    this.functions[name] = wrappedFunc;\n    \n    // Mark as async if needed\n    if (isAsync) {\n      this.asyncFunctions.add(name);\n    }\n    \n    return wrappedFunc;\n  }\n\n  /**\n   * Get a value from the JSON data by key\n   * @param {string} key - The key to lookup\n   * @returns {*} The value or null if not found\n   */\n  io_get(key) {\n    if (key in this.jsonData) {\n      const value = this.jsonData[key];\n      \n      // If it's an array, make a copy to prevent modification of the original\n      if (Array.isArray(value)) {\n        return [...value];\n      }\n      \n      return value;\n    }\n    \n    return null;\n  }\n\n  /**\n   * Put a value into the JSON data by key\n   * \n   * This method handles two calling conventions:\n   * 1. io_put(key, value) - Direct call with two arguments\n   * 2. io_put([key, value]) - Call with arguments as an array (from CallExpression)\n   * \n   * @param {string|Array} key - The key or [key, value] array\n   * @param {*} value - The value (optional if key is an array)\n   * @returns {*} The stored value\n   */\n  io_put(key, value) {\n    let actualKey, actualValue;\n    \n    // Handle both calling conventions\n    if (Array.isArray(key) && value === undefined) {\n      // Called as io_put([key, value]) from CallExpression\n      [actualKey, actualValue] = key;\n    } else {\n      // Called as io_put(key, value) directly\n      actualKey = key;\n      actualValue = value;\n    }\n    \n    this.jsonData[actualKey] = actualValue;\n    return actualValue;\n  }\n\n  /**\n   * Output a value to the console\n   * @param {*} value - The value to output\n   * @returns {*} The original value\n   */\n  console_put(value) {\n    // Handle array case from CallExpression\n    const actualValue = Array.isArray(value) && value.length === 1 ? value[0] : value;\n    \n    // Convert to string and add to console output\n    this.consoleOutput.push(this.stringify(actualValue));\n    \n    return actualValue;\n  }\n\n  /**\n   * Create a child context for a function call\n   * @param {Object} [parameterVars={}] - Variables to initialize in the child context (function parameters)\n   * @returns {EvaluationContext} A new child context\n   */\n  createChildContext(parameterVars = {}) {\n    // Create a new context that inherits from this context for closure support\n    const childContext = new EvaluationContext(this.jsonData, this.consoleOutput, this);\n    \n    // Copy registered functions\n    Object.keys(this.functions).forEach(key => {\n      childContext.functions[key] = this.functions[key];\n      \n      if (this.asyncFunctions.has(key)) {\n        childContext.asyncFunctions.add(key);\n      }\n    });\n    \n    // Set up parameter variables if provided\n    if (parameterVars && typeof parameterVars === 'object') {\n      Object.keys(parameterVars).forEach(key => {\n        childContext.variables[key] = parameterVars[key];\n      });\n    }\n    \n    return childContext;\n  }\n} ","/**\n * Abstract Syntax Tree (AST) node classes for our language\n * Following Niklaus Wirth's approach of simple, clear node structures\n */\n\nimport { ReturnValue, RuntimeError, LibraryFunction } from './runtime.js';\n\n// Base Node class\nexport class Node {\n  constructor() {\n    this.position = { line: 0, column: 0 };\n  }\n  \n  // For debugging - by default return the constructor name\n  toString() {\n    return this.constructor.name;\n  }\n  \n  // Return a JSON representation of the node for AST visualization\n  toJSON() {\n    return {\n      type: this.constructor.name,\n      ...this\n    };\n  }\n  \n  // Base evaluate method - should be overridden by derived classes\n  async evaluate(context) {\n    throw new Error(`${this.constructor.name} does not implement evaluate()`);\n  }\n}\n\n// Program is the root node of every AST\nexport class Program extends Node {\n  constructor() {\n    super();\n    this.statements = [];\n  }\n  \n  toJSON() {\n    return {\n      type: 'Program',\n      statements: this.statements.map(stmt => stmt.toJSON())\n    };\n  }\n  \n  async evaluate(context) {\n    let result = null;\n    \n    for (const statement of this.statements) {\n      result = await statement.evaluate(context);\n      \n      // Early return if we hit a return statement\n      if (result instanceof ReturnValue) {\n        return result.value;\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Statement nodes\n\nexport class BlockStatement extends Node {\n  constructor() {\n    super();\n    this.statements = [];\n  }\n  \n  toJSON() {\n    return {\n      type: 'BlockStatement',\n      position: this.position,\n      statements: this.statements.map(stmt => stmt.toJSON())\n    };\n  }\n  \n  async evaluate(context) {\n    let result = null;\n    \n    for (const statement of this.statements) {\n      result = await statement.evaluate(context);\n      \n      // Early return from blocks if we hit a return statement\n      if (result instanceof ReturnValue) {\n        return result;\n      }\n    }\n    \n    return result;\n  }\n}\n\nexport class ExpressionStatement extends Node {\n  constructor(expression) {\n    super();\n    this.expression = expression;\n  }\n  \n  toJSON() {\n    return {\n      type: 'ExpressionStatement',\n      position: this.position,\n      expression: this.expression ? this.expression.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    return await this.expression.evaluate(context);\n  }\n}\n\nexport class VariableDeclaration extends Node {\n  constructor(name, initializer) {\n    super();\n    this.name = name;\n    this.initializer = initializer;\n  }\n  \n  toJSON() {\n    return {\n      type: 'VariableDeclaration',\n      position: this.position,\n      name: this.name,\n      initializer: this.initializer ? this.initializer.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const value = this.initializer ? await this.initializer.evaluate(context) : null;\n    return context.getEnvironment().define(this.name, value);\n  }\n}\n\nexport class AssignmentStatement extends Node {\n  constructor(name, value) {\n    super();\n    this.name = name;\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'AssignmentStatement',\n      position: this.position,\n      name: this.name,\n      value: this.value ? this.value.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const value = await this.value.evaluate(context);\n    \n    // Try to assign directly to the context's variables\n    try {\n      return context.assignVariable(this.name, value);\n    } catch (error) {\n      // If that fails, try to assign to the environment\n      try {\n        return context.getEnvironment().assign(this.name, value, this.position);\n      } catch (envError) {\n        throw new RuntimeError(\n          `Cannot assign to undefined variable '${this.name}'`,\n          this.position.line,\n          this.position.column\n        );\n      }\n    }\n  }\n}\n\nexport class FunctionDeclaration extends Node {\n  constructor(name, parameters, body) {\n    super();\n    this.name = name;\n    this.parameters = parameters || [];\n    this.body = body;\n  }\n  \n  toJSON() {\n    return {\n      type: 'FunctionDeclaration',\n      position: this.position,\n      name: this.name,\n      parameters: this.parameters,\n      body: this.body ? this.body.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    // Create a function that captures the current context for closure support\n    const func = async (args) => {\n      // Create parameter object to initialize the child context\n      const paramVars = {};\n      \n      // Bind arguments to parameters\n      for (let i = 0; i < this.parameters.length; i++) {\n        const param = this.parameters[i];\n        const arg = i < args.length ? args[i] : null;\n        paramVars[param] = arg;\n      }\n      \n      // Create a new child context that inherits from the current context (closure)\n      // and initialize it with the parameter variables\n      const functionContext = context.createChildContext(paramVars);\n      \n      let result;\n      try {\n        result = await this.body.evaluate(functionContext);\n      } catch (error) {\n        throw error;\n      }\n      \n      // Unwrap ReturnValue if present\n      if (result instanceof ReturnValue) {\n        return result.value;\n      }\n      \n      return result;\n    };\n    \n    // If this is a named function, store it in the environment\n    if (this.name) {\n      return context.getEnvironment().define(this.name, func);\n    }\n    \n    // For anonymous functions, return the function directly\n    return func;\n  }\n}\n\nexport class ReturnStatement extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'ReturnStatement',\n      position: this.position,\n      value: this.value ? this.value.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const value = this.value ? await this.value.evaluate(context) : null;\n    return new ReturnValue(value);\n  }\n}\n\nexport class IfStatement extends Node {\n  constructor(condition, consequence, alternative) {\n    super();\n    this.condition = condition;\n    this.consequence = consequence;\n    this.alternative = alternative;\n  }\n  \n  toJSON() {\n    return {\n      type: 'IfStatement',\n      position: this.position,\n      condition: this.condition ? this.condition.toJSON() : null,\n      consequence: this.consequence ? this.consequence.toJSON() : null,\n      alternative: this.alternative ? this.alternative.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const condition = await this.condition.evaluate(context);\n    \n    if (isTruthy(condition)) {\n      return await this.consequence.evaluate(context);\n    } else if (this.alternative) {\n      return await this.alternative.evaluate(context);\n    }\n    \n    return null;\n  }\n}\n\nexport class WhileStatement extends Node {\n  constructor(condition, body) {\n    super();\n    this.condition = condition;\n    this.body = body;\n  }\n  \n  toJSON() {\n    return {\n      type: 'WhileStatement',\n      position: this.position,\n      condition: this.condition ? this.condition.toJSON() : null,\n      body: this.body ? this.body.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    let result = null;\n    \n    while (isTruthy(await this.condition.evaluate(context))) {\n      result = await this.body.evaluate(context);\n      \n      // Handle return statements inside the loop\n      if (result instanceof ReturnValue) {\n        return result;\n      }\n    }\n    \n    return result;\n  }\n}\n\n// Expression nodes\n\nexport class Identifier extends Node {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n  \n  toJSON() {\n    return {\n      type: 'Identifier',\n      position: this.position,\n      name: this.name\n    };\n  }\n  \n  async evaluate(context) {\n    try {\n      // First try to look up via the context's lookupVariable method\n      // which also checks for functions\n      return context.lookupVariable(this.name);\n    } catch (error) {\n      // If that fails, fall back to environment if it exists\n      try {\n        if (context.getEnvironment) {\n          return context.getEnvironment().get(this.name, this.position);\n        }\n      } catch (envError) {\n        // Ignore environment error, we'll throw our own below\n      }\n      \n      throw new RuntimeError(\n        `Undefined variable '${this.name}'`,\n        this.position.line,\n        this.position.column\n      );\n    }\n  }\n}\n\nexport class NumberLiteral extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'NumberLiteral',\n      position: this.position,\n      value: this.value\n    };\n  }\n  \n  async evaluate(context) {\n    return this.value;\n  }\n}\n\nexport class StringLiteral extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'StringLiteral',\n      position: this.position,\n      value: this.value\n    };\n  }\n  \n  async evaluate(context) {\n    return this.value;\n  }\n}\n\nexport class BooleanLiteral extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  \n  toJSON() {\n    return {\n      type: 'BooleanLiteral',\n      position: this.position,\n      value: this.value\n    };\n  }\n  \n  async evaluate(context) {\n    return this.value;\n  }\n}\n\nexport class NullLiteral extends Node {\n  constructor() {\n    super();\n  }\n  \n  toJSON() {\n    return {\n      type: 'NullLiteral',\n      position: this.position\n    };\n  }\n  \n  async evaluate(context) {\n    return null;\n  }\n}\n\nexport class PrefixExpression extends Node {\n  constructor(operator, right) {\n    super();\n    this.operator = operator;\n    this.right = right;\n  }\n  \n  toJSON() {\n    return {\n      type: 'PrefixExpression',\n      position: this.position,\n      operator: this.operator,\n      right: this.right ? this.right.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const right = await this.right.evaluate(context);\n    \n    switch (this.operator) {\n      case '-':\n        return -right;\n      case '!':\n        return !isTruthy(right);\n      default:\n        throw new RuntimeError(\n          `Unknown prefix operator: ${this.operator}`,\n          this.position.line,\n          this.position.column\n        );\n    }\n  }\n}\n\nexport class InfixExpression extends Node {\n  constructor(left, operator, right) {\n    super();\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n  \n  toJSON() {\n    return {\n      type: 'InfixExpression',\n      position: this.position,\n      left: this.left ? this.left.toJSON() : null,\n      operator: this.operator,\n      right: this.right ? this.right.toJSON() : null\n    };\n  }\n  \n  async evaluate(context) {\n    const left = await this.left.evaluate(context);\n    \n    // Short-circuit for logical operators\n    if (this.operator === '&&') {\n      return isTruthy(left) ? await this.right.evaluate(context) : left;\n    }\n    \n    if (this.operator === '||') {\n      return isTruthy(left) ? left : await this.right.evaluate(context);\n    }\n    \n    const right = await this.right.evaluate(context);\n    \n    switch (this.operator) {\n      case '+':\n        // Handle string concatenation\n        if (typeof left === 'string' || typeof right === 'string') {\n          return String(left) + String(right);\n        }\n        return left + right;\n      \n      case '-':\n        return left - right;\n      \n      case '*':\n        return left * right;\n      \n      case '/':\n        if (right === 0) {\n          throw new RuntimeError(\n            'Division by zero',\n            this.position.line,\n            this.position.column\n          );\n        }\n        return left / right;\n      \n      case '%':\n        if (right === 0) {\n          throw new RuntimeError(\n            'Modulo by zero',\n            this.position.line,\n            this.position.column\n          );\n        }\n        return left % right;\n      \n      case '<':\n        return left < right;\n      \n      case '>':\n        return left > right;\n      \n      case '<=':\n        return left <= right;\n      \n      case '>=':\n        return left >= right;\n      \n      case '==':\n        return left === right;\n      \n      case '!=':\n        return left !== right;\n      \n      default:\n        throw new RuntimeError(\n          `Unknown infix operator: ${this.operator}`,\n          this.position.line,\n          this.position.column\n        );\n    }\n  }\n}\n\nexport class CallExpression extends Node {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.arguments = args || [];\n  }\n  \n  toJSON() {\n    return {\n      type: 'CallExpression',\n      callee: this.callee ? this.callee.toJSON() : null,\n      arguments: this.arguments.map(arg => arg.toJSON())\n    };\n  }\n  \n  async evaluate(context) {\n    // First, evaluate the arguments\n    const args = [];\n    for (const arg of this.arguments) {\n      try {\n        const value = await arg.evaluate(context);\n        args.push(value);\n      } catch (error) {\n        throw error;\n      }\n    }\n    \n    // Then evaluate the callee\n    let callee;\n    try {\n      callee = await this.callee.evaluate(context);\n    } catch (error) {\n      throw error;\n    }\n    \n    // Check if it's a library function\n    if (callee instanceof LibraryFunction) {\n      // Handle async library functions\n      if (callee.isAsync) {\n        return await callee.implementation(...args);\n      } else {\n        // Keep backward compatibility with sync library functions\n        return callee.implementation(...args);\n      }\n    }\n    \n    // Check if it's a user-defined function\n    if (typeof callee === 'function') {\n      // Check if this is an async function\n      const funcName = this.callee.name; // Assuming callee is an Identifier\n      if (funcName && context.isAsyncFunction && context.isAsyncFunction(funcName)) {\n        // User defined async functions expect args as a single array\n        return await callee(args);\n      } else {\n        // User defined functions in this interpreter expect args as a single array\n        // and we want to make sure arrays inside args aren't nested unnecessarily\n        return callee(args);\n      }\n    }\n    \n    throw new RuntimeError(\n      `Cannot call non-function: ${context.stringify(callee)}`,\n      this.position.line,\n      this.position.column\n    );\n  }\n}\n\nexport class MemberExpression extends Node {\n  constructor(object, property, computed = false) {\n    super();\n    this.object = object;       // The object being accessed\n    this.property = property;   // The property being accessed\n    this.computed = computed;   // Whether this is computed access e.g. obj[expr] (true) or obj.prop (false)\n  }\n  \n  toJSON() {\n    return {\n      type: 'MemberExpression',\n      position: this.position,\n      object: this.object ? this.object.toJSON() : null,\n      property: this.property ? this.property.toJSON() : null,\n      computed: this.computed\n    };\n  }\n  \n  async evaluate(context) {\n    const object = await this.object.evaluate(context);\n    let property;\n    \n    if (this.computed) {\n      // Computed member access: obj[expr]\n      property = await this.property.evaluate(context);\n    } else {\n      // Static member access: obj.prop\n      property = this.property.name;\n    }\n    \n    if (object === null || object === undefined) {\n      throw new Error('Cannot access property of null or undefined');\n    }\n    \n    return object[property];\n  }\n}\n\nexport class ArrayLiteral extends Node {\n  constructor(elements = []) {\n    super();\n    this.elements = elements;\n  }\n  \n  toJSON() {\n    return {\n      type: 'ArrayLiteral',\n      position: this.position,\n      elements: this.elements.map(e => e ? e.toJSON() : null)\n    };\n  }\n  \n  async evaluate(context) {\n    const result = [];\n    for (const element of this.elements) {\n      result.push(await element.evaluate(context));\n    }\n    return result;\n  }\n}\n\n// Helper function to determine if a value is truthy\nfunction isTruthy(value) {\n  if (value === null) return false;\n  if (typeof value === 'boolean') return value;\n  if (typeof value === 'number') return value !== 0;\n  if (typeof value === 'string') return value.length > 0;\n  return true;\n} ","import { TokenType } from './tokens.js';\nimport * as AST from './ast.js';\n\n/**\n * Precedence levels for operators\n */\nconst PRECEDENCE = {\n  LOWEST: 1,\n  OR: 2,      // ||\n  AND: 3,     // &&\n  EQUALS: 4,  // == !=\n  COMPARE: 5, // > >= < <=\n  SUM: 6,     // + -\n  PRODUCT: 7, // * / %\n  PREFIX: 8,  // -x !x\n  CALL: 9,    // myFunction(x)\n  MEMBER: 10, // obj.property\n};\n\n// Mapping of token types to their respective precedence\nconst PRECEDENCES = {\n  [TokenType.OR]: PRECEDENCE.OR,\n  [TokenType.AND]: PRECEDENCE.AND,\n  [TokenType.EQ]: PRECEDENCE.EQUALS,\n  [TokenType.NOT_EQ]: PRECEDENCE.EQUALS,\n  [TokenType.LT]: PRECEDENCE.COMPARE,\n  [TokenType.GT]: PRECEDENCE.COMPARE,\n  [TokenType.LT_EQ]: PRECEDENCE.COMPARE,\n  [TokenType.GT_EQ]: PRECEDENCE.COMPARE,\n  [TokenType.PLUS]: PRECEDENCE.SUM,\n  [TokenType.MINUS]: PRECEDENCE.SUM,\n  [TokenType.ASTERISK]: PRECEDENCE.PRODUCT,\n  [TokenType.SLASH]: PRECEDENCE.PRODUCT,\n  [TokenType.PERCENT]: PRECEDENCE.PRODUCT,\n  [TokenType.LPAREN]: PRECEDENCE.CALL,\n  [TokenType.DOT]: PRECEDENCE.MEMBER,\n  [TokenType.LBRACKET]: PRECEDENCE.MEMBER,\n};\n\n/**\n * Parser class for converting tokens into an AST\n * Implementation of a predictive recursive descent parser (LL(1))\n * as described in Wirth's \"Compilerbau\" (Compiler Construction)\n */\nexport class Parser {\n  constructor(lexer) {\n    this.lexer = lexer;\n    this.tokens = [];\n    this.currentPosition = 0;\n    this.errors = [];\n    \n    // Initialize with next two tokens\n    this.nextToken();\n    this.nextToken();\n    \n    // Register parsing functions for different types of expressions\n    this.prefixParseFns = new Map();\n    this.infixParseFns = new Map();\n    \n    // Register prefix parsers\n    this.registerPrefix(TokenType.IDENTIFIER, this.parseIdentifier.bind(this));\n    this.registerPrefix(TokenType.NUMBER, this.parseNumberLiteral.bind(this));\n    this.registerPrefix(TokenType.STRING, this.parseStringLiteral.bind(this));\n    this.registerPrefix(TokenType.TRUE, this.parseBooleanLiteral.bind(this));\n    this.registerPrefix(TokenType.FALSE, this.parseBooleanLiteral.bind(this));\n    this.registerPrefix(TokenType.NULL, this.parseNullLiteral.bind(this));\n    this.registerPrefix(TokenType.LPAREN, this.parseGroupedExpression.bind(this));\n    this.registerPrefix(TokenType.MINUS, this.parsePrefixExpression.bind(this));\n    this.registerPrefix(TokenType.NOT, this.parsePrefixExpression.bind(this));\n    this.registerPrefix(TokenType.LBRACKET, this.parseArrayLiteral.bind(this));\n    this.registerPrefix(TokenType.DEF, this.parseAnonymousFunction.bind(this));\n    \n    // Register infix parsers\n    this.registerInfix(TokenType.PLUS, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.MINUS, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.ASTERISK, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.SLASH, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.PERCENT, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.NOT_EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.LT, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.GT, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.LT_EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.GT_EQ, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.AND, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.OR, this.parseInfixExpression.bind(this));\n    this.registerInfix(TokenType.LPAREN, this.parseCallExpression.bind(this));\n    this.registerInfix(TokenType.DOT, this.parseMemberExpression.bind(this));\n    this.registerInfix(TokenType.LBRACKET, this.parseIndexExpression.bind(this));\n  }\n  \n  /**\n   * Parse the entire program\n   */\n  parseProgram() {\n    const program = new AST.Program();\n    \n    while (!this.currentTokenIs(TokenType.EOF)) {\n      const stmt = this.parseStatement();\n      if (stmt) {\n        program.statements.push(stmt);\n      }\n      this.nextToken();\n    }\n    \n    return program;\n  }\n  \n  /**\n   * Register a prefix parse function\n   */\n  registerPrefix(tokenType, fn) {\n    this.prefixParseFns.set(tokenType, fn);\n  }\n  \n  /**\n   * Register an infix parse function\n   */\n  registerInfix(tokenType, fn) {\n    this.infixParseFns.set(tokenType, fn);\n  }\n  \n  /**\n   * Advance to the next token\n   */\n  nextToken() {\n    this.currentToken = this.peekToken;\n    \n    if (this.currentPosition < this.tokens.length) {\n      this.peekToken = this.tokens[this.currentPosition];\n      this.currentPosition++;\n    } else {\n      const nextToken = this.lexer.nextToken();\n      this.tokens.push(nextToken);\n      this.peekToken = nextToken;\n      this.currentPosition++;\n    }\n  }\n  \n  /**\n   * Check if the current token is of the given type\n   */\n  currentTokenIs(tokenType) {\n    return this.currentToken && this.currentToken.type === tokenType;\n  }\n  \n  /**\n   * Check if the next token is of the given type\n   */\n  peekTokenIs(tokenType) {\n    return this.peekToken && this.peekToken.type === tokenType;\n  }\n  \n  /**\n   * Expect the next token to be of the given type, and advance if it is\n   */\n  expectPeek(tokenType) {\n    if (this.peekTokenIs(tokenType)) {\n      this.nextToken();\n      return true;\n    } else {\n      this.peekError(tokenType);\n      return false;\n    }\n  }\n  \n  /**\n   * Add a peek error\n   */\n  peekError(tokenType) {\n    const msg = `Expected next token to be ${tokenType}, got ${this.peekToken?.type} instead`;\n    this.errors.push({\n      message: msg,\n      line: this.peekToken?.line,\n      column: this.peekToken?.column\n    });\n  }\n  \n  /**\n   * Get the precedence of the next token\n   */\n  peekPrecedence() {\n    return PRECEDENCES[this.peekToken?.type] || PRECEDENCE.LOWEST;\n  }\n  \n  /**\n   * Get the precedence of the current token\n   */\n  currentPrecedence() {\n    return PRECEDENCES[this.currentToken?.type] || PRECEDENCE.LOWEST;\n  }\n  \n  /**\n   * Parse a statement\n   */\n  parseStatement() {\n    switch (this.currentToken.type) {\n      case TokenType.DEF:\n        return this.parseFunctionDeclaration();\n      case TokenType.LET:\n        return this.parseVariableDeclaration();\n      case TokenType.IF:\n        return this.parseIfStatement();\n      case TokenType.WHILE:\n        return this.parseWhileStatement();\n      case TokenType.RETURN:\n        return this.parseReturnStatement();\n      case TokenType.LBRACE:\n        return this.parseBlockStatement();\n      default:\n        // Check for assignment statements (identifier = expression)\n        if (this.currentTokenIs(TokenType.IDENTIFIER) && this.peekTokenIs(TokenType.ASSIGN)) {\n          return this.parseAssignmentStatement();\n        }\n        return this.parseExpressionStatement();\n    }\n  }\n  \n  /**\n   * Parse a block statement\n   */\n  parseBlockStatement() {\n    const block = new AST.BlockStatement();\n    block.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    this.nextToken(); // Skip the opening brace\n    \n    while (!this.currentTokenIs(TokenType.RBRACE) && !this.currentTokenIs(TokenType.EOF)) {\n      const stmt = this.parseStatement();\n      if (stmt) {\n        block.statements.push(stmt);\n      }\n      this.nextToken();\n    }\n    \n    if (!this.currentTokenIs(TokenType.RBRACE)) {\n      this.errors.push({\n        message: \"Expected '}' at the end of block statement\",\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n    }\n    \n    return block;\n  }\n  \n  /**\n   * Parse a function declaration\n   */\n  parseFunctionDeclaration() {\n    const functionDecl = new AST.FunctionDeclaration();\n    functionDecl.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Skip the 'def' keyword\n    this.nextToken();\n    \n    // Check if this is an anonymous function\n    if (this.currentTokenIs(TokenType.LPAREN)) {\n      // Anonymous function, no name\n      functionDecl.parameters = this.parseFunctionParameters();\n    } else {\n      // Named function\n      if (!this.currentTokenIs(TokenType.IDENTIFIER)) {\n        this.errors.push({\n          message: \"Expected function name or parameters\",\n          line: this.currentToken?.line,\n          column: this.currentToken?.column\n        });\n        return null;\n      }\n      \n      functionDecl.name = this.currentToken.literal;\n      \n      // Parse parameters\n      if (!this.expectPeek(TokenType.LPAREN)) {\n        return null;\n      }\n      \n      functionDecl.parameters = this.parseFunctionParameters();\n    }\n    \n    // Parse function body\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    functionDecl.body = this.parseBlockStatement();\n    \n    return functionDecl;\n  }\n  \n  /**\n   * Parse an anonymous function expression\n   * This is used when 'def' is found in an expression context\n   */\n  parseAnonymousFunction() {\n    const functionExpr = new AST.FunctionDeclaration();\n    functionExpr.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Skip the 'def' keyword\n    this.nextToken();\n    \n    // Parse parameters\n    if (!this.currentTokenIs(TokenType.LPAREN)) {\n      this.errors.push({\n        message: \"Expected '(' after 'def' in anonymous function\",\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n      return null;\n    }\n    \n    functionExpr.parameters = this.parseFunctionParameters();\n    \n    // Parse function body\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    functionExpr.body = this.parseBlockStatement();\n    \n    return functionExpr;\n  }\n  \n  /**\n   * Parse function parameters\n   */\n  parseFunctionParameters() {\n    const parameters = [];\n    \n    // Empty parameter list\n    if (this.peekTokenIs(TokenType.RPAREN)) {\n      this.nextToken();\n      return parameters;\n    }\n    \n    this.nextToken();\n    \n    // First parameter\n    parameters.push(this.currentToken.literal);\n    \n    // Subsequent parameters\n    while (this.peekTokenIs(TokenType.COMMA)) {\n      this.nextToken(); // Skip comma\n      this.nextToken(); // Move to parameter name\n      \n      if (this.currentTokenIs(TokenType.IDENTIFIER)) {\n        parameters.push(this.currentToken.literal);\n      } else {\n        this.errors.push({\n          message: \"Expected parameter name\",\n          line: this.currentToken?.line,\n          column: this.currentToken?.column\n        });\n      }\n    }\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    return parameters;\n  }\n  \n  /**\n   * Parse a variable declaration\n   */\n  parseVariableDeclaration() {\n    const declaration = new AST.VariableDeclaration();\n    declaration.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse variable name\n    if (!this.expectPeek(TokenType.IDENTIFIER)) {\n      return null;\n    }\n    \n    declaration.name = this.currentToken.literal;\n    \n    // Parse initializer (if any)\n    if (this.peekTokenIs(TokenType.ASSIGN)) {\n      this.nextToken();\n      this.nextToken();\n      declaration.initializer = this.parseExpression(PRECEDENCE.LOWEST);\n    }\n    \n    // Expect semicolon\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    } else {\n      this.errors.push({\n        message: \"Expected ';' after variable declaration\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n    }\n    \n    return declaration;\n  }\n  \n  /**\n   * Parse an assignment statement\n   */\n  parseAssignmentStatement() {\n    const assignment = new AST.AssignmentStatement();\n    assignment.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    assignment.name = this.currentToken.literal;\n    \n    this.nextToken(); // Skip the identifier\n    this.nextToken(); // Skip the '='\n    \n    assignment.value = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    // Expect semicolon\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    } else {\n      this.errors.push({\n        message: \"Expected ';' after assignment\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n    }\n    \n    return assignment;\n  }\n  \n  /**\n   * Parse an assignment expression without requiring a semicolon\n   * This is specifically used in for loop initializers and updates\n   */\n  parseAssignmentExpression() {\n    const assignment = new AST.AssignmentStatement();\n    assignment.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    assignment.name = this.currentToken.literal;\n    \n    this.nextToken(); // Skip the identifier\n    this.nextToken(); // Skip the '='\n    \n    assignment.value = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    // No semicolon expectation here\n    return assignment;\n  }\n  \n  /**\n   * Parse an if statement\n   */\n  parseIfStatement() {\n    const ifStmt = new AST.IfStatement();\n    ifStmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse the condition\n    if (!this.expectPeek(TokenType.LPAREN)) {\n      return null;\n    }\n    \n    this.nextToken(); // Skip the '('\n    ifStmt.condition = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    // Parse the consequence (if block)\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    ifStmt.consequence = this.parseBlockStatement();\n    \n    // Parse the alternative (else block) if it exists\n    if (this.peekTokenIs(TokenType.ELSE)) {\n      this.nextToken();\n      \n      if (this.peekTokenIs(TokenType.IF)) {\n        // This is an \"else if\"\n        this.nextToken();\n        ifStmt.alternative = this.parseIfStatement();\n      } else if (this.peekTokenIs(TokenType.LBRACE)) {\n        // This is a regular \"else\"\n        this.nextToken();\n        ifStmt.alternative = this.parseBlockStatement();\n      } else {\n        this.errors.push({\n          message: \"Expected 'if' or '{' after 'else'\",\n          line: this.peekToken?.line,\n          column: this.peekToken?.column\n        });\n      }\n    }\n    \n    return ifStmt;\n  }\n  \n  /**\n   * Parse a while statement\n   */\n  parseWhileStatement() {\n    const whileStmt = new AST.WhileStatement();\n    whileStmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Parse condition\n    if (!this.expectPeek(TokenType.LPAREN)) {\n      return null;\n    }\n    \n    this.nextToken(); // Skip the '('\n    whileStmt.condition = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    // Parse loop body\n    if (!this.expectPeek(TokenType.LBRACE)) {\n      return null;\n    }\n    \n    whileStmt.body = this.parseBlockStatement();\n    \n    return whileStmt;\n  }\n  \n  /**\n   * Parse a return statement\n   */\n  parseReturnStatement() {\n    const returnStmt = new AST.ReturnStatement();\n    returnStmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    this.nextToken(); // Skip 'return' keyword\n    \n    // Check for expression after return\n    if (!this.currentTokenIs(TokenType.SEMICOLON)) {\n      returnStmt.value = this.parseExpression(PRECEDENCE.LOWEST);\n    }\n    \n    // Expect semicolon\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    } else {\n      this.errors.push({\n        message: \"Expected ';' after return statement\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n    }\n    \n    return returnStmt;\n  }\n  \n  /**\n   * Parse an expression statement\n   */\n  parseExpressionStatement() {\n    const stmt = new AST.ExpressionStatement(this.parseExpression(PRECEDENCE.LOWEST));\n    stmt.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Expect semicolon (optional)\n    if (this.peekTokenIs(TokenType.SEMICOLON)) {\n      this.nextToken();\n    }\n    \n    return stmt;\n  }\n  \n  /**\n   * Parse an expression\n   */\n  parseExpression(precedence) {\n    const prefixFn = this.prefixParseFns.get(this.currentToken.type);\n    \n    if (!prefixFn) {\n      this.errors.push({\n        message: `No prefix parse function for ${this.currentToken.type} found`,\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n      return null;\n    }\n    \n    let leftExp = prefixFn();\n    \n    while (!this.peekTokenIs(TokenType.SEMICOLON) && precedence < this.peekPrecedence()) {\n      const infixFn = this.infixParseFns.get(this.peekToken.type);\n      \n      if (!infixFn) {\n        return leftExp;\n      }\n      \n      this.nextToken();\n      leftExp = infixFn(leftExp);\n    }\n    \n    return leftExp;\n  }\n  \n  /**\n   * Parse an identifier\n   */\n  parseIdentifier() {\n    const identifier = new AST.Identifier(this.currentToken.literal);\n    identifier.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return identifier;\n  }\n  \n  /**\n   * Parse a number literal\n   */\n  parseNumberLiteral() {\n    const number = new AST.NumberLiteral(this.currentToken.literal.includes('.') \n      ? parseFloat(this.currentToken.literal) \n      : parseInt(this.currentToken.literal, 10));\n    number.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return number;\n  }\n  \n  /**\n   * Parse a string literal\n   */\n  parseStringLiteral() {\n    const string = new AST.StringLiteral(this.currentToken.literal);\n    string.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return string;\n  }\n  \n  /**\n   * Parse a boolean literal\n   */\n  parseBooleanLiteral() {\n    const boolean = new AST.BooleanLiteral(this.currentToken.type === TokenType.TRUE);\n    boolean.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return boolean;\n  }\n  \n  /**\n   * Parse a null literal\n   */\n  parseNullLiteral() {\n    const nullLiteral = new AST.NullLiteral();\n    nullLiteral.position = { line: this.currentToken.line, column: this.currentToken.column };\n    return nullLiteral;\n  }\n  \n  /**\n   * Parse a grouped expression (inside parentheses)\n   */\n  parseGroupedExpression() {\n    this.nextToken(); // Skip the '('\n    \n    const exp = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    if (!this.expectPeek(TokenType.RPAREN)) {\n      return null;\n    }\n    \n    return exp;\n  }\n  \n  /**\n   * Parse a prefix expression\n   */\n  parsePrefixExpression() {\n    const expression = new AST.PrefixExpression(\n      this.currentToken.literal,\n      null // right expression will be set below\n    );\n    expression.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    this.nextToken();\n    expression.right = this.parseExpression(PRECEDENCE.PREFIX);\n    \n    return expression;\n  }\n  \n  /**\n   * Parse an infix expression\n   */\n  parseInfixExpression(left) {\n    const expression = new AST.InfixExpression(\n      left,\n      this.currentToken.literal,\n      null // right expression will be set below\n    );\n    expression.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    const precedence = this.currentPrecedence();\n    this.nextToken();\n    expression.right = this.parseExpression(precedence);\n    \n    return expression;\n  }\n  \n  /**\n   * Parse a function call expression\n   */\n  parseCallExpression(callee) {\n    const expression = new AST.CallExpression(callee, []);\n    expression.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    expression.arguments = this.parseCallArguments();\n    \n    return expression;\n  }\n  \n  /**\n   * Parse function call arguments\n   */\n  parseCallArguments() {\n    return this.parseExpressionList(TokenType.RPAREN);\n  }\n  \n  /**\n   * Parse a member expression (object.property)\n   */\n  parseMemberExpression(object) {\n    const memberExp = new AST.MemberExpression(\n      object,\n      null, // property will be set below\n      false // not computed\n    );\n    memberExp.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Skip the dot\n    this.nextToken();\n    \n    // Check if the property name is an identifier\n    if (!this.currentTokenIs(TokenType.IDENTIFIER)) {\n      this.errors.push({\n        message: `Expected property name after dot operator, got ${this.currentToken.type}`,\n        line: this.currentToken?.line,\n        column: this.currentToken?.column\n      });\n      return null;\n    }\n    \n    // Set the property name as an identifier\n    memberExp.property = this.parseIdentifier();\n    \n    return memberExp;\n  }\n  \n  /**\n   * Parse an index expression (object[index])\n   */\n  parseIndexExpression(object) {\n    const indexExp = new AST.MemberExpression(\n      object,\n      null, // property will be set below\n      true  // computed access\n    );\n    indexExp.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    // Skip the opening bracket\n    this.nextToken();\n    \n    // Parse the index expression\n    indexExp.property = this.parseExpression(PRECEDENCE.LOWEST);\n    \n    // Expect closing bracket\n    if (!this.expectPeek(TokenType.RBRACKET)) {\n      this.errors.push({\n        message: \"Expected ']' after index expression\",\n        line: this.peekToken?.line,\n        column: this.peekToken?.column\n      });\n      return null;\n    }\n    \n    return indexExp;\n  }\n  \n  /**\n   * Parse an array literal\n   */\n  parseArrayLiteral() {\n    const array = new AST.ArrayLiteral();\n    array.position = { line: this.currentToken.line, column: this.currentToken.column };\n    \n    array.elements = this.parseExpressionList(TokenType.RBRACKET);\n    \n    return array;\n  }\n  \n  /**\n   * Parse a list of expressions\n   */\n  parseExpressionList(endToken) {\n    const expressions = [];\n    \n    // Handle empty list\n    if (this.peekTokenIs(endToken)) {\n      this.nextToken();\n      return expressions;\n    }\n    \n    // Skip opening delimiter\n    this.nextToken();\n    \n    // Parse first expression\n    expressions.push(this.parseExpression(PRECEDENCE.LOWEST));\n    \n    // Parse remaining expressions\n    while (this.peekTokenIs(TokenType.COMMA)) {\n      this.nextToken(); // Skip comma\n      this.nextToken(); // Move to next expression\n      expressions.push(this.parseExpression(PRECEDENCE.LOWEST));\n    }\n    \n    // Expect closing delimiter\n    if (!this.expectPeek(endToken)) {\n      return null;\n    }\n    \n    return expressions;\n  }\n} ","import { Lexer } from './lexer.js';\nimport { Parser } from './parser.js';\nimport { EvaluationContext, RuntimeError, ReturnValue } from './runtime.js';\n\n/**\n * Main Interpreter class that orchestrates lexing, parsing, and evaluation of code.\n * This is the primary entry point for using the interpreter.\n */\nexport class Interpreter {\n  /**\n   * Creates a new Interpreter instance with fresh context.\n   * The interpreter provides a clean environment for parsing and evaluating code.\n   * Each parse/evaluate cycle uses its own internal state to prevent side effects\n   * between different code executions.\n   * \n   * @example\n   * ```javascript\n   * const interpreter = new Interpreter();\n   * const parseResult = interpreter.parse('let x = 42;');\n   * if (parseResult.success) {\n   *   const jsonData = {};\n   *   const consoleOutput = [];\n   *   const evalResult = await interpreter.evaluate(jsonData, consoleOutput);\n   *   console.log(evalResult);\n   * }\n   * ```\n   */\n  constructor() {\n    this.ast = null;\n    this.errors = [];\n    // Create evaluation context during initialization\n    this.context = new EvaluationContext();\n    \n    // Register built-in functions\n    this.registerBuiltInFunctions();\n  }\n  \n  /**\n   * Register built-in functions that should be available by default\n   */\n  registerBuiltInFunctions() {\n    // Register console_put and io functions as library functions\n    this.registerFunction('console_put', (value) => {\n      return this.context.console_put(value);\n    });\n    \n    this.registerFunction('io_get', (key) => {\n      return this.context.io_get(key);\n    });\n    \n    this.registerFunction('io_put', (key, value) => {\n      return this.context.io_put(key, value);\n    });\n  }\n  \n  /**\n   * Parse the source code and generate an AST\n   */\n  parse(sourceCode) {\n    try {\n      // Create lexer and parser\n      const lexer = new Lexer(sourceCode);\n      const parser = new Parser(lexer);\n      \n      // Parse the program to generate AST\n      this.ast = parser.parseProgram();\n      \n      // Collect any errors from the parser\n      this.errors = parser.errors;\n      \n      return {\n        success: this.errors.length === 0,\n        ast: this.ast,\n        errors: this.errors\n      };\n    } catch (error) {\n      this.errors.push({\n        message: `Unexpected error: ${error.message}`,\n        line: 0,\n        column: 0\n      });\n      \n      return {\n        success: false,\n        ast: null,\n        errors: this.errors\n      };\n    }\n  }\n  \n  /**\n   * Evaluate the AST and return the result\n   */\n  async evaluate(jsonData = {}, consoleOutput = []) {\n    this.errors = [];\n    \n    try {\n      // Create a new context that will directly modify the provided jsonData and consoleOutput\n      const prevContext = this.context;\n      this.context = new EvaluationContext(jsonData, consoleOutput);\n      \n      // Copy registered functions from previous context if it exists\n      if (prevContext && prevContext.functions) {\n        // Deep copy functions to ensure they're preserved\n        this.context.functions = { ...prevContext.functions };\n        \n        // Copy async functions\n        if (prevContext.asyncFunctions) {\n          this.context.asyncFunctions = new Set([...prevContext.asyncFunctions]);\n        }\n      } else {\n        // Re-register built-in functions if we don't have a previous context\n        this.registerBuiltInFunctions();\n      }\n      \n      // Check if we have a valid AST\n      if (!this.ast) {\n        this.errors.push({\n          message: 'No AST to evaluate. Parse code first.',\n          line: 0,\n          column: 0\n        });\n        \n        return {\n          success: false,\n          result: null,\n          jsonData,\n          consoleOutput,\n          errors: this.errors\n        };\n      }\n      \n      // Evaluate the program - the consoleOutput and jsonData will be modified directly\n      const result = await evaluate(this.ast, this.context);\n      \n      return {\n        success: true,\n        result,\n        jsonData,\n        consoleOutput,\n        errors: []\n      };\n    } catch (error) {\n      // Handle runtime errors\n      if (error instanceof RuntimeError) {\n        this.errors.push({\n          message: error.message,\n          line: error.line,\n          column: error.column\n        });\n      } else {\n        // Handle unexpected errors\n        this.errors.push({\n          message: `Unexpected error: ${error.message}`,\n          line: 0,\n          column: 0\n        });\n      }\n      \n      return {\n        success: false,\n        result: null,\n        jsonData,\n        consoleOutput,\n        errors: this.errors\n      };\n    }\n  }\n  \n  /**\n   * Register a custom library function\n   * @param {string} name - The name of the function\n   * @param {Function} implementation - The function implementation\n   * @param {boolean} isAsync - Whether the function is asynchronous (defaults to false)\n   * @returns {Function} The wrapped function\n   */\n  registerFunction(name, implementation, isAsync = false) {\n    if (!this.context) {\n      this.context = new EvaluationContext();\n    }\n    \n    return this.context.registerFunction(name, implementation, isAsync);\n  }\n  \n  /**\n   * Get the current evaluation context\n   */\n  getContext() {\n    return this.context;\n  }\n  \n  /**\n   * Return a JSON representation of the AST for visualization\n   */\n  getAstJson() {\n    if (!this.ast) {\n      return null;\n    }\n    \n    return this.ast.toJSON();\n  }\n  \n  /**\n   * Format errors into a readable string\n   */\n  formatErrors() {\n    if (this.errors.length === 0) {\n      return \"No errors\";\n    }\n    \n    return this.errors.map(error => {\n      return `[${error.line}:${error.column}] ${error.message}`;\n    }).join('\\n');\n  }\n}\n\n/**\n * Evaluate an AST in a given context\n * @param {Object} ast - The abstract syntax tree\n * @param {EvaluationContext} context - The evaluation context\n * @returns {*} The result of evaluation\n */\nexport async function evaluate(ast, context) {\n  // If the AST is an instance of a class rather than a plain object,\n  // and it has an evaluate method, use that directly\n  if (ast && typeof ast === 'object' && typeof ast.evaluate === 'function') {\n    return await ast.evaluate(context);\n  }\n\n  // Handle nodes defined as plain objects with type property\n  if (!ast || !ast.type) {\n    // Special case for Program node where type might not be directly defined\n    if (ast && (ast.statements || ast.body)) {\n      let result = null;\n      const statements = ast.statements || ast.body;\n      for (const statement of statements) {\n        result = await evaluate(statement, context);\n      }\n      return result;\n    }\n    throw new Error('Invalid AST node');\n  }\n\n  switch (ast.type) {\n    case 'Program': {\n      let result = null;\n      const statements = ast.statements || ast.body || [];\n      for (const statement of statements) {\n        result = await evaluate(statement, context);\n      }\n      return result;\n    }\n\n    case 'NumericLiteral':\n    case 'NumberLiteral':\n      return ast.value;\n\n    case 'StringLiteral':\n      return ast.value;\n      \n    case 'Identifier': {\n      // Important: Handle identifiers which may be variables or functions\n      const name = ast.name;\n      return context.lookupVariable(name);\n    }\n    \n    case 'BinaryExpression':\n    case 'InfixExpression': {\n      const left = await evaluate(ast.left, context);\n      const right = await evaluate(ast.right, context);\n\n      switch (ast.operator) {\n        case '+': return left + right;\n        case '-': return left - right;\n        case '*': return left * right;\n        case '/': return left / right;\n        case '%': return left % right;\n        case '<': return left < right;\n        case '>': return left > right;\n        case '<=': return left <= right;\n        case '>=': return left >= right;\n        case '==': return left === right;\n        case '!=': return left !== right;\n        case '&&': return left && right;\n        case '||': return left || right;\n        default: throw new Error(`Unknown binary operator: ${ast.operator}`);\n      }\n    }\n    \n    case 'UnaryExpression':\n    case 'PrefixExpression': {\n      const argument = await evaluate(ast.argument || ast.right, context);\n      switch (ast.operator) {\n        case '-': return -argument;\n        case '!': return !argument;\n        default: throw new Error(`Unknown unary operator: ${ast.operator}`);\n      }\n    }\n    \n    case 'VariableDeclaration': {\n      const initializer = ast.initializer || ast.init;\n      const varValue = initializer ? await evaluate(initializer, context) : undefined;\n      return context.assignVariable(ast.name || (ast.id && ast.id.name), varValue);\n    }\n\n    case 'AssignmentExpression':\n    case 'AssignmentStatement': {\n      let leftName;\n      if (ast.name) {\n        leftName = ast.name;\n      } else if (ast.left && ast.left.type === 'Identifier') {\n        leftName = ast.left.name;\n      } else {\n        throw new Error('Left side of assignment must be an identifier');\n      }\n      const assignValue = await evaluate(ast.right || ast.value, context);\n      return context.assignVariable(leftName, assignValue);\n    }\n\n    case 'BlockStatement': {\n      let blockResult = null;\n      const blockStatements = ast.statements || ast.body || [];\n      for (const statement of blockStatements) {\n        blockResult = await evaluate(statement, context);\n        \n        // Early return if we encounter a ReturnValue\n        if (blockResult instanceof ReturnValue) {\n          return blockResult;\n        }\n      }\n      return blockResult;\n    }\n\n    case 'IfStatement': {\n      const test = await evaluate(ast.test || ast.condition, context);\n      if (test) {\n        return await evaluate(ast.consequent || ast.consequence, context);\n      } else if (ast.alternate || ast.alternative) {\n        return await evaluate(ast.alternate || ast.alternative, context);\n      }\n      return null;\n    }\n\n    case 'WhileStatement': {\n      let whileResult = null;\n      const whileCondition = ast.test || ast.condition;\n      const whileBody = ast.body;\n      \n      while (await evaluate(whileCondition, context)) {\n        whileResult = await evaluate(whileBody, context);\n        \n        // Early return if we hit a return statement\n        if (whileResult instanceof ReturnValue) {\n          return whileResult;\n        }\n      }\n      return whileResult;\n    }\n\n    case 'CallExpression': {\n      // Extract the function name and handle different node structures\n      let functionName = null;\n      let callee = null;\n      \n      if (ast.callee) {\n        if (typeof ast.callee === 'string') {\n          functionName = ast.callee;\n        } else if (ast.callee.type === 'Identifier') {\n          functionName = ast.callee.name;\n        } else {\n          // This might be a complex expression that evaluates to a function\n          // For example, an anonymous function\n          callee = await evaluate(ast.callee, context);\n        }\n      }\n      \n      // Evaluate all arguments regardless of the callee type\n      const args = [];\n      for (const arg of (ast.arguments || [])) {\n        args.push(await evaluate(arg, context));\n      }\n      \n      // If we have a direct callee from an expression evaluation, use it\n      if (callee && typeof callee === 'function') {\n        const result = await callee(args);\n        // Unwrap ReturnValue if present\n        if (result instanceof ReturnValue) {\n          return result.value;\n        }\n        return result;\n      }\n      \n      // Otherwise, use the function name to look up the function\n      if (functionName) {\n        // First check for library functions directly\n        const libraryFunc = context.lookupFunction(functionName);\n        \n        if (libraryFunc) {\n          // Check if this is an async function\n          if (context.isAsyncFunction && context.isAsyncFunction(functionName)) {\n            return await libraryFunc(...args);\n          } else {\n            return libraryFunc(...args);\n          }\n        }\n        \n        // Then check for special IO functions (for backward compatibility)\n        if (functionName === 'io_get' && ast.arguments && ast.arguments.length === 1) {\n          const key = args[0];\n          return context.io_get(key);\n        }\n        \n        if (functionName === 'io_put' && ast.arguments && ast.arguments.length === 2) {\n          const key = args[0];\n          const value = args[1];\n          return context.io_put(key, value);\n        }\n        \n        if (functionName === 'console_put' && ast.arguments && ast.arguments.length >= 1) {\n          const value = args[0];\n          return context.console_put(value);\n        }\n        \n        // Look up the function in the context\n        try {\n          const func = context.lookupVariable(functionName);\n          \n          // Handle different function types\n          if (typeof func === 'function') {\n            // This is a function we can directly call (likely from FunctionDeclaration)\n            return await func(args);\n          } else if (typeof func === 'object' && func !== null && 'params' in func && 'body' in func) {\n            // Legacy format - function stored as an object with params and body\n            // Create a new context with function parameters\n            const callContext = context.createChildContext();\n            \n            // Bind arguments to parameters\n            for (let i = 0; i < func.params.length; i++) {\n              callContext.assignVariable(func.params[i], args[i] || null);\n            }\n            \n            // Copy registered functions to new context\n            for (const key in context.functions) {\n              callContext.registerFunction(\n                key, \n                context.functions[key], \n                context.asyncFunctions && context.asyncFunctions.has(key)\n              );\n            }\n            \n            // Evaluate the function body with the new context\n            const result = await evaluate(func.body, callContext);\n            \n            // Return the result - it could be a ReturnValue which needs unwrapping\n            if (result && typeof result === 'object' && result.type === 'ReturnValue') {\n              return result.value;\n            }\n            \n            return result;\n          }\n        } catch (error) {\n          // Function lookup failed, will throw below\n        }\n      }\n      \n      // If we get here, we're calling a non-function\n      throw new Error(`Cannot call non-function: ${functionName || 'unknown'}`);\n    }\n\n    case 'ReturnStatement':\n      if (ast.argument || ast.value) {\n        const returnValue = await evaluate(ast.argument || ast.value, context);\n        return new ReturnValue(returnValue);\n      }\n      return new ReturnValue(null);\n\n    case 'ArrayExpression': {\n      const elements = [];\n      for (const element of (ast.elements || [])) {\n        elements.push(await evaluate(element, context));\n      }\n      return elements;\n    }\n\n    case 'ObjectExpression': {\n      const obj = {};\n      for (const property of (ast.properties || [])) {\n        const key = property.key.type === 'Identifier' \n          ? property.key.name \n          : await evaluate(property.key, context);\n        obj[key] = await evaluate(property.value, context);\n      }\n      return obj;\n    }\n\n    case 'MemberExpression': {\n      const object = await evaluate(ast.object, context);\n      const property = ast.computed \n        ? await evaluate(ast.property, context)\n        : ast.property.name;\n      \n      if (object === null || object === undefined) {\n        throw new Error('Cannot access property of null or undefined');\n      }\n      \n      return object[property];\n    }\n\n    case 'ExpressionStatement':\n      return await evaluate(ast.expression, context);\n\n    default:\n      throw new Error(`Unknown AST node type: ${ast.type}`);\n  }\n} ","import { useState } from 'react';\nimport SourceEditor from './SourceEditor';\nimport ConsoleOutput from './ConsoleOutput';\nimport JsonEditor from './JsonEditor';\nimport { Interpreter } from '../../interpreter';\n\n// Default values for the editors\nconst DEFAULT_SOURCE = `let hello = io_get(\"hello\");\nif (hello == \"Hello World\") {\n  hello = \"Hallo Welt\";\n}\nelse {\n  hello = \"Hello World\";\n}\nio_put(\"hello\", hello);`;\n\nconst DEFAULT_JSON_DATA = `{\n  \"hello\": \"Hello World\"\n}`;\n\nfunction IDE() {\n  const [source, setSource] = useState(DEFAULT_SOURCE);\n  const [jsonData, setJsonData] = useState(DEFAULT_JSON_DATA);\n  const [output, setOutput] = useState('');\n  \n  const handleRun = async () => {\n    try {\n      // Start with a fresh console output\n      setOutput('$ Parsing program...\\n');\n      \n      // Create a fresh interpreter instance to avoid any caching issues\n      const interpreter = new Interpreter();\n      \n      // Parse the source code\n      const parseResult = interpreter.parse(source);\n      \n      if (parseResult.success) {\n        setOutput('$ Parsing program...\\n$ Parsing successful!\\n\\n');\n        \n        try {\n          // Parse the JSON data\n          const parsedJsonData = JSON.parse(jsonData);\n          \n          // Create an array to capture console output\n          const consoleOutput = [];\n          \n          // Execute the program\n          setOutput('$ Executing program...\\n');\n          // await the evaluation since it's now async\n          const evalResult = await interpreter.evaluate(parsedJsonData, consoleOutput);\n          \n          if (evalResult.success) {\n            // Format the updated JSON\n            const updatedJson = JSON.stringify(evalResult.jsonData, null, 2);\n            \n            // Update the JSON editor with the new values\n            setJsonData(updatedJson);\n            \n            // Format and display console output\n            const formattedOutput = consoleOutput.map(line => `> ${line}`).join('\\n');\n            \n            setOutput('$ Program output:\\n' +\n              formattedOutput + '\\n\\n' +\n              '$ Result: ' + (evalResult.result !== undefined ? JSON.stringify(evalResult.result) : 'undefined')\n            );\n          } else {\n            // Show execution errors\n            const errorMessages = evalResult.errors.map(err => \n              `[${err.line}:${err.column}] ${err.message}`\n            ).join('\\n');\n            \n            setOutput(prevOutput => \n              prevOutput + \n              '$ Execution failed!\\n\\n' + \n              errorMessages\n            );\n          }\n        } catch (error) {\n          // Differentiate between JSON parsing errors and other errors\n          if (error instanceof SyntaxError && error.message.includes('JSON')) {\n            setOutput(prevOutput => \n              prevOutput + \n              `$ JSON parsing error: ${error.message}\\n` +\n              '$ Please check your JSON data and try again.'\n            );\n          } else {\n            setOutput(prevOutput => \n              prevOutput + \n              `$ Unexpected error: ${error.message}\\n` +\n              '$ Please check your code and try again.'\n            );\n          }\n        }\n      } else {\n        // Show parsing errors\n        const errorMessages = parseResult.errors.map(err => \n          `[${err.line}:${err.column}] ${err.message}`\n        ).join('\\n');\n        \n        setOutput('$ Parsing program...\\n$ Parsing failed!\\n\\n' + errorMessages);\n      }\n    } catch (error) {\n      setOutput(`$ Error: ${error.message}`);\n    }\n  };\n  \n  return (\n    <div className=\"flex flex-col h-[calc(100vh-200px)] gap-4\">\n      <div className=\"flex flex-grow gap-4 min-h-0\">\n        {/* Left side: Source Editor (takes 2/3 of the width) */}\n        <div className=\"w-2/3 min-h-0 flex flex-col\">\n          <SourceEditor \n            source={source} \n            onSourceChange={setSource} \n            onRun={handleRun} \n          />\n        </div>\n        \n        {/* Right side: JSON Editor (takes 1/3 of the width) */}\n        <div className=\"w-1/3 min-h-0\">\n          <JsonEditor\n            jsonData={jsonData}\n            onJsonChange={setJsonData}\n          />\n        </div>\n      </div>\n      \n      {/* Bottom: Console Output (fixed height) */}\n      <div className=\"h-1/3 min-h-0\">\n        <ConsoleOutput output={output} />\n      </div>\n    </div>\n  );\n}\n\nexport default IDE; ","import IDE from '../components/ide/IDE';\n\nfunction Home() {\n  return (\n    <div className=\"py-6\">\n      <IDE />\n    </div>\n  );\n}\n\nexport default Home; ","import { Routes, Route } from 'react-router-dom';\nimport Layout from './components/Layout';\nimport Home from './pages/Home';\n\nfunction App() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<Layout />}>\n        <Route index element={<Home />} />\n      </Route>\n    </Routes>\n  );\n}\n\nexport default App;\n","import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport { BrowserRouter } from 'react-router-dom'\nimport App from './App.jsx'\nimport './index.css'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode>\n    <BrowserRouter basename={import.meta.env.BASE_URL}>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>,\n)\n"],"names":["relList","document","createElement","supports","link","querySelectorAll","processPreload","MutationObserver","mutations","mutation","type","node","addedNodes","tagName","rel","observe","childList","subtree","ep","fetchOpts","script","integrity","referrerpolicy","referrerPolicy","crossorigin","credentials","getFetchOpts","fetch","href","m","require$$0","Header","className","children","Footer","year","Date","getFullYear","Layout","_jsx","Outlet","SourceEditor","source","onSourceChange","onRun","_jsxs","onClick","xmlns","viewBox","fill","fillRule","d","clipRule","placeholder","value","onChange","e","target","spellCheck","ConsoleOutput","output","role","JsonEditor","jsonData","onJsonChange","client","createRoot","hydrateRoot","TokenType","Keywords","def","let","if","else","while","return","true","false","null","Token","constructor","literal","line","column","this","toString","Lexer","input","position","readPosition","ch","readChar","length","peekChar","nextToken","token","skipWhitespace","skipComments","startColumn","stringLiteral","readString","isLetter","identifier","readIdentifier","isDigit","number","readNumber","slice","quote","commentEnd","tokenize","tokens","push","ReturnValue","LibraryFunction","name","jsFunction","isAsync","implementation","RuntimeError","Error","message","super","Environment","parent","values","Map","libraryFunctions","extend","define","set","get","has","assign","registerLibraryFunction","libraryFunction","EvaluationContext","consoleOutput","parentContext","variables","functions","asyncFunctions","Set","environment","getEnvironment","stringify","JSON","String","lookupVariable","assignVariable","lookupFunction","isAsyncFunction","registerFunction","func","wrappedFunc","args","Array","isArray","some","item","add","io_get","key","io_put","actualKey","actualValue","console_put","createChildContext","parameterVars","childContext","Object","keys","forEach","Node","toJSON","evaluate","context","Program","statements","map","stmt","result","statement","BlockStatement","ExpressionStatement","expression","VariableDeclaration","initializer","AssignmentStatement","error","envError","FunctionDeclaration","parameters","body","async","paramVars","i","param","arg","functionContext","ReturnStatement","IfStatement","condition","consequence","alternative","isTruthy","WhileStatement","Identifier","NumberLiteral","StringLiteral","BooleanLiteral","NullLiteral","PrefixExpression","operator","right","InfixExpression","left","CallExpression","callee","arguments","funcName","MemberExpression","object","property","computed","ArrayLiteral","elements","element","PRECEDENCE","PRECEDENCES","TokenType_OR","TokenType_AND","TokenType_EQ","TokenType_NOT_EQ","TokenType_LT","TokenType_GT","TokenType_LT_EQ","TokenType_GT_EQ","TokenType_PLUS","TokenType_MINUS","TokenType_ASTERISK","TokenType_SLASH","TokenType_PERCENT","TokenType_LPAREN","TokenType_DOT","TokenType_LBRACKET","Parser","lexer","currentPosition","errors","prefixParseFns","infixParseFns","registerPrefix","parseIdentifier","bind","parseNumberLiteral","parseStringLiteral","parseBooleanLiteral","parseNullLiteral","parseGroupedExpression","parsePrefixExpression","parseArrayLiteral","parseAnonymousFunction","registerInfix","parseInfixExpression","parseCallExpression","parseMemberExpression","parseIndexExpression","parseProgram","program","AST.Program","currentTokenIs","parseStatement","tokenType","fn","currentToken","peekToken","peekTokenIs","expectPeek","peekError","msg","_a","_b","_c","peekPrecedence","currentPrecedence","parseFunctionDeclaration","parseVariableDeclaration","parseIfStatement","parseWhileStatement","parseReturnStatement","parseBlockStatement","parseAssignmentStatement","parseExpressionStatement","block","AST.BlockStatement","functionDecl","AST.FunctionDeclaration","parseFunctionParameters","functionExpr","declaration","AST.VariableDeclaration","parseExpression","assignment","AST.AssignmentStatement","parseAssignmentExpression","ifStmt","AST.IfStatement","whileStmt","AST.WhileStatement","returnStmt","AST.ReturnStatement","AST.ExpressionStatement","precedence","prefixFn","leftExp","infixFn","AST.Identifier","AST.NumberLiteral","includes","parseFloat","parseInt","string","AST.StringLiteral","boolean","AST.BooleanLiteral","nullLiteral","AST.NullLiteral","exp","AST.PrefixExpression","AST.InfixExpression","AST.CallExpression","parseCallArguments","parseExpressionList","memberExp","AST.MemberExpression","indexExp","array","AST.ArrayLiteral","endToken","expressions","Interpreter","ast","registerBuiltInFunctions","parse","sourceCode","parser","success","prevContext","getContext","getAstJson","formatErrors","join","argument","init","varValue","id","leftName","assignValue","blockResult","blockStatements","test","consequent","alternate","whileResult","whileCondition","whileBody","functionName","libraryFunc","callContext","params","returnValue","obj","properties","DEFAULT_SOURCE","DEFAULT_JSON_DATA","IDE","setSource","useState","setJsonData","setOutput","interpreter","parseResult","parsedJsonData","evalResult","updatedJson","formattedOutput","undefined","errorMessages","err","prevOutput","SyntaxError","Home","App","Routes","Route","path","index","ReactDOM","getElementById","render","React","StrictMode","BrowserRouter","basename","import"],"mappings":"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"}